<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Learn & Think]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://shawnelee88.github.io//"/>
  <updated>2015-07-28T14:32:12.000Z</updated>
  <id>http://shawnelee88.github.io//</id>
  
  <author>
    <name><![CDATA[如花]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[IOS_FAQ]]></title>
    <link href="http://shawnelee88.github.io/2015/07/28/IOS-FAQ/"/>
    <id>http://shawnelee88.github.io/2015/07/28/IOS-FAQ/</id>
    <published>2015-07-28T14:32:12.000Z</published>
    <updated>2015-07-28T14:32:12.000Z</updated>
    <content type="html"><![CDATA[<p>工具类</p>
<ul>
<li><a href="http://blog.csdn.net/ayaseeli/article/details/41725923" target="_blank" rel="external">xcode6如何创建空的Empty Application?</a></li>
<li><a href="http://jingyan.baidu.com/article/3c343ff7efd4860d377963cd.html" target="_blank" rel="external">xcode6如何创建category文件</a></li>
</ul>
<p>语言小知识</p>
<ul>
<li>asdf</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[关于工具以及ios开发的一些小tips]]>
    
    </summary>
    
      <category term="ios" scheme="http://shawnelee88.github.io/tags/ios/"/>
    
      <category term="oc" scheme="http://shawnelee88.github.io/tags/oc/"/>
    
      <category term="ios" scheme="http://shawnelee88.github.io/categories/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://shawnelee88.github.io/2015/07/16/hello-world/"/>
    <id>http://shawnelee88.github.io/2015/07/16/hello-world/</id>
    <published>2015-07-16T12:50:27.000Z</published>
    <updated>2015-07-09T13:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[proxychains+shadowsocks神器]]></title>
    <link href="http://shawnelee88.github.io/2015/07/10/proxychains-shadowsocks%E7%A5%9E%E5%99%A8/"/>
    <id>http://shawnelee88.github.io/2015/07/10/proxychains-shadowsocks神器/</id>
    <published>2015-07-10T15:14:11.000Z</published>
    <updated>2015-07-10T15:35:57.000Z</updated>
    <content type="html"><![CDATA[<p>安装了shadowsocks之后，只能网页出去逛逛，如果需要在command line中也能有同样的效果（ping不同，但是可以下载），需要配合proxychains4这个神器</p>
<h2 id="安装">安装</h2><p>1.mac shadows安装简单</p>
<p>2.proxychains</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="keyword">cd</span> proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">(sudo) <span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br><span class="line"><span class="keyword">cp</span> ./src/proxychains.<span class="keyword">conf</span> /etc/proxychians.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cd</span> .. &amp;&amp; rm -rf proxychains-ng</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">brew install proxychains-ng  //mac</span><br></pre></td></tr></table></figure>
<h2 id="修改配置">修改配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vim</span> /etc/proxychains.conf</span><br><span class="line">推荐配置</span><br><span class="line">strict_chain</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet <span class="number">224</span></span><br><span class="line">tcp_read_time_out <span class="number">15000</span></span><br><span class="line">tcp_connect_time_out <span class="number">8000</span></span><br><span class="line">localnet <span class="number">127.0.0.0</span>/<span class="number">255.0.0.0</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  <span class="number">127.0.0.1</span> <span class="number">1080</span></span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl https:<span class="comment">//www.twitter.com/</span></span><br><span class="line">proxychains4 git <span class="keyword">push</span> origin master</span><br></pre></td></tr></table></figure>
<h2 id="测试proxychains4">测试proxychains4</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="keyword">https</span>://www.dropbox.com -v -O /dev/<span class="constant">null</span>   <span class="comment"> //直接输入这条语句连接不了</span></span><br><span class="line">proxychains4 wget <span class="keyword">https</span>://www.dropbox.com -v -O /dev/<span class="constant">null</span>  <span class="comment"> //加入proxychains4之后就可以顺利执行</span></span><br></pre></td></tr></table></figure>
<p>参考来源：</p>
<ul>
<li><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks官网—github</a></li>
<li><a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">proxychains4神器官网—github</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks/wiki/Using-Shadowsocks-with-Command-Line-Tools" target="_blank" rel="external">shadowsocks 官网wiki—配置proxychains</a></li>
<li><a href="http://blog.ainhaato.moe/proxychains-socks5-shell/" target="_blank" rel="external">利用proxychains在终端使用socks5代理</a></li>
<li><a href="http://blog.ihipop.info/2011/01/1988.html" target="_blank" rel="external">在终端下间接使用Socks5代理的几种方法(privoxy,tsocks,proxychains)—比较老，可以参考</a></li>
<li><a href="http://wsgzao.github.io/post/fq/" target="_blank" rel="external">gfw小结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[shadowsocks+proxychains神器，一枝红杏出墙来]]>
    
    </summary>
    
      <category term="proxychains" scheme="http://shawnelee88.github.io/tags/proxychains/"/>
    
      <category term="shadowsocks" scheme="http://shawnelee88.github.io/tags/shadowsocks/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC杂记]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/mac%E6%9D%82%E8%AE%B0/"/>
    <id>http://shawnelee88.github.io/2015/07/09/mac杂记/</id>
    <published>2015-07-09T14:35:41.000Z</published>
    <updated>2015-07-19T01:48:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="技巧">技巧</h3><h4 id="显示隐藏文件：">显示隐藏文件：</h4><p>显示：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code></p>
<p>隐藏：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></p>
<p>隐藏某个文件夹：<br><code>chflags hidden /Users/lee/Downloads/未命名文件夹</code></p>
<p>取消隐藏某个文件夹<br><code>chflags nohidden /Users/lee/Downloads/未命名文件夹</code></p>
<h4 id="objdump—otool">objdump—otool</h4><p>objdump是linux下的工具，而mac提供的是<a href="http://blog.csdn.net/x32sky/article/details/45099979" target="_blank" rel="external">otool</a>，<br><code>objdump -Sl 类似于 otool -tv</code></p>
<p><a href="https://support.apple.com/zh-cn/HT204048" target="_blank" rel="external">mac安装windows(怎么卸载，怎么安装多个，todo)</a></p>
<h4 id="DigitalOcean相关：">DigitalOcean相关：</h4><p>官网3部曲：</p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-connect-to-your-droplet-with-ssh" target="_blank" rel="external">How To Connect To Your Droplet with SSH</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="external">Initial Server Setup with Ubuntu 14.04</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/additional-recommended-steps-for-new-ubuntu-14-04-servers" target="_blank" rel="external">Additional Recommended Steps for New Ubuntu 14.04 Servers</a></p>
<h4 id="如何比较好的卸载nodejs相关">如何比较好的卸载nodejs相关</h4><p>使用相关shell脚本即可<a href="[uninstallNodejs.sh--github](https://github.com/jesseyu/uninstallNodejs/blob/master/uninstallNodejs.sh)">^node</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">lsbom <span class="operator">-f</span> <span class="operator">-l</span> <span class="operator">-s</span> -pf /var/db/receipts/org.nodejs.pkg.bom \</span><br><span class="line">| <span class="keyword">while</span> <span class="built_in">read</span> i; <span class="keyword">do</span></span><br><span class="line">  sudo rm /usr/<span class="built_in">local</span>/<span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node \</span><br><span class="line">     /usr/<span class="built_in">local</span>/lib/node_modules \</span><br><span class="line">     /var/db/receipts/org.nodejs.*</span><br></pre></td></tr></table></figure>
<h3 id="软件">软件</h3><p><a href="http://synergy-project.org/?utm_referrer=http%3A%2F%2Fsynergy-project.org%2Fdownload%2F&amp;utm_expid=35973112-5.LQhO_zr3R7mw69eKHqIeWg.0" target="_blank" rel="external">多屏幕局域网内鼠标键盘共享软件synergy</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Mac OSX的一些记录]]>
    
    </summary>
    
      <category term="mac" scheme="http://shawnelee88.github.io/tags/mac/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/tags/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
      <category term="mac" scheme="http://shawnelee88.github.io/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OC学习笔记]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/OC%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shawnelee88.github.io/2015/07/09/OC编程学习/</id>
    <published>2015-07-09T14:35:41.000Z</published>
    <updated>2015-07-19T03:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>oc以c语言为基础，加入了对面向对象编程（OOP）的支持。</p>
<p>工具：xcode6</p>
<p>书籍：《Objective-C编程》—Aaron Hillegass[美]</p>
<h2 id="变量与类型">变量与类型</h2><h3 id="变量使用前必须声明，理由有2：">变量使用前必须声明，理由有2：</h3><ul>
<li>有了类型信息，编译器可以检测潜在的错误，比如将对字符串进行数学运算</li>
<li>根据类型分配存储空间</li>
</ul>
<h3 id="常用类型：">常用类型：</h3><p>c语言5种常用类型：</p>
<ul>
<li>整型: int, short, long</li>
<li>浮点: float, double</li>
<li>字符: char</li>
<li>指针: int *</li>
<li>结构体: struct</li>
</ul>
<h3 id="id">id</h3><p><code>id</code>：声明指针时并不知道所指对象的准确类型。为此，可以使用id类型。id的含义是：指针，并可以指向任意类型的Objective-C对象.<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="keyword">delegate</span>; <span class="comment">//不需要使用星号，本身就有星号的作用</span></span><br></pre></td></tr></table></figure></p>
<h3 id="局部变量，全局变量，静态变量">局部变量，全局变量，静态变量</h3><p>局部变量：函数运行时才会存在，调用函数时自动分配，函数结束后自动释放，也称<code>自动变量</code><br>全局变量：函数外声明，到处可以访问，其他文件如需访问，用extern<br>静态变量：只有在该文件内可以访问</p>
<hr>
<h2 id="oc与框架（framework）">oc与框架（framework）</h2><p>框架：有很多类组成的库<br>类：负责描述某个特定类型的对象，包括实例方法（instance method）和实例变量（instance variable）<br>实例：通过某个类创建的对象</p>
<h3 id="消息机制">消息机制</h3><h4 id="消息发送">消息发送</h4><p>消息发送必须写在一堆方括号中，并且必须包含以下两部分：<br>1.指针，指向接受消息的对象—接收方<br>2.方法名，要触发的方法的方法名—选择器<br>3.可以传入参数—参数<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[now dateByAddingTimeInterval:10000]</span>;</span><br><span class="line"><span class="attribute">now</span>:接收方</span><br><span class="line"><span class="attribute">dateByAddingTimeInterval</span>:选择器</span><br><span class="line"><span class="number">10000</span>:参数</span><br></pre></td></tr></table></figure></p>
<p>要调用方法，就需要向对象发送对应的消息，此为与c语言不同的地方。</p>
<h4 id="消息嵌套发送">消息嵌套发送</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSDate alloc] init]</span><br></pre></td></tr></table></figure>
<p>系统会先向NSDate类发送alloc消息，得到返回值（指向新建的NSDate实例的指针），再向这个指针发送init消息，再返回该对象的指针，alloc负责分配内存，init负责初始化里面的数据</p>
<h4 id="消息可以不带参数，也可以带多个参数">消息可以不带参数，也可以带多个参数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSDate</span> alloc]</span><br><span class="line"><span class="built_in">NSCalendar</span> *cal = [<span class="built_in">NSCalendar</span> currnetCalendar];</span><br><span class="line"><span class="built_in">NSUinteger</span> day = [cal ordinalityOfUnit:<span class="built_in">NSDayCalendarUnit</span> inUnit:<span class="built_in">NSMonthCalendarUnit</span> forDate:now];  </span><br><span class="line"><span class="comment">//方法为ordinalityOfUnit:inUnit:forDate:, 传入3个参数,用来计算某个某个日期是响应月份中的第几日</span></span><br></pre></td></tr></table></figure>
<h4 id="方法也可以分为类方法以及对象方法">方法也可以分为类方法以及对象方法</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[NSDate alloc]</span> <span class="comment">//对类NSDate发送alloc消息</span></span><br><span class="line"><span class="attr_selector">[NSDate alloc]</span> <span class="tag">init</span>]  <span class="comment">//alloc返回的结果是某个实例的指针，对该指针发送init消息</span></span><br></pre></td></tr></table></figure>
<h4 id="向nil发送消息">向nil发送消息</h4><p>大多数语言中，不允许向nil发送消息，oc则不同，允许向nil发送消息，什么事情都不会发生。<br>note1：如果程序向某个对象发送了消息，但是没有得到预期的结果，需检查消息接收方是否为nil<br>note2：向nil发送消息，得到的返回值没有意义</p>
<h4 id="@的几种含义">@的几种含义</h4><p>1.用在NSLog中<br>2.<code>%@</code>可以表示指向任何对象，会向对象发送<code>description</code>方法 eg:NSLog(@”%@…”)</p>
<h3 id="NSArray">NSArray</h3><h4 id="两种枚举方法">两种枚举方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *dateList = [<span class="built_in">NSArray</span> arrayWithObjects:date1, date2, date3];</span><br><span class="line"><span class="built_in">NSUInteger</span> count = [dateList count];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;[dateList objectAtIndex:i];&#125;  <span class="comment">//普通枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSDate</span> *d <span class="keyword">in</span> dateList)&#123;&#125;    <span class="comment">//快速枚举，不应在枚举过程中增加或删除数组中的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="两种类型的数组">两种类型的数组</h4><p>1.NSArray,创建后不能增加或删除元素<br>2.NSMutableArray：可以增加或删除元素，是NSArray的子类<br>其他类也会有类似的两种不同类型，NSSet, NSMutableSet； NSDictionary,NSMutableDictionary</p>
<hr>
<h2 id="自定义类">自定义类</h2><h3 id="存取方法">存取方法</h3><p>3种存取方法<br>1.函数实现存取方法<br>2.点号存取<br>3.属性 property, synthesize</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;   </span><br><span class="line">@interface <span class="keyword">Person</span> : NSObject </span><br><span class="line">&#123;     </span><br><span class="line">float heightInMeters;     </span><br><span class="line">int weightInKilos; </span><br><span class="line">&#125;   </span><br><span class="line">// 通过以下方法，可以存取相应的实例变量 </span><br><span class="line">- (float)heightInMeters; </span><br><span class="line">- (void)setHeightInMeters:(float)height; </span><br><span class="line">- (int)weightInKilos; </span><br><span class="line">- (void)setWeightInKilos:(int)weight; </span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[]</span><span class="comment">[Person alloc]</span> init];</span><br><span class="line"><span class="comment">[person setWeightInKilos:96]</span>;  //函数实现存取方法</span><br><span class="line"><span class="comment">[person setHeightInMeters:1.8]</span>;</span><br><span class="line">int w = <span class="comment">[person weightInKilos]</span>;</span><br><span class="line">int h = <span class="comment">[person heightInMeters]</span>;</span><br><span class="line"><span class="keyword">person</span>.weightInKilos = 96;  //点号存取方法</span><br><span class="line"><span class="keyword">person</span>.heightInMeters = 1.8;</span><br><span class="line">int w1 = <span class="keyword">person</span>.weightInKilos;</span><br><span class="line">int h1 = <span class="keyword">person</span>.heightInMeters;</span><br><span class="line">//头文件中用@property属性</span><br><span class="line">@property float heightInMeters</span><br><span class="line">@property int weightInKilos;</span><br><span class="line">//实现文件中用@synthesize属性,会自动合成存取方法</span><br><span class="line">@synthesize heightInMeters, weightInKilos;</span><br></pre></td></tr></table></figure>
<h3 id="self">self</h3><p>类似于c++的this指针，指向运行当前方法的对象的指针，当需要向自己发送消息时，就需要使用self。</p>
<hr>
<h2 id="继承">继承</h2><p>ios sdk中得类都继承自NSObject（直接或间接地），他虽然拥有很多方法，但是只有1个实例变量：<code>isa指针</code>，任何对象的isa指针都会指向创建该对象的类，可以理解为“is-a”</p>
<blockquote>
<p>任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。—<a href="http://blog.csdn.net/wishfly/article/details/7384708" target="_blank" rel="external">Objective-C内存布局—描述isa指针</a>)</p>
</blockquote>
<p>消息的响应过程—继承链往上依次查找：</p>
<p>假设程序向某个对象发送了一个fido消息。收到消息的对象为了能响应这个消息，会通过isa指针找到该对象的类并查询“是否有名为fido的实例方法？”如果这个类拥有名为fido的方法，就会执行之。如果没有，就会向该类的父类查询象会沿着继承链向上查询，直到找到名为fido的方法，或者到达继承链的顶端为止。如果一直没有找到fido方法，并且位于继承链顶端的NSObject也回答“没有实现fido方法”时，程序就会报错</p>
<h3 id="super">super</h3><p>运行指定的方法，但是从对象的父类开始查找与之匹配的实现。与self相对应。</p>
<hr>
<h2 id="对象实例变量">对象实例变量</h2><p>指向另一个对象的指针，可用于描述相应两个对象之间的关系</p>
<p>三种常见用途：<br>对象属性—指针，指向某个单一的、代表某个值的对象，比如NSString,NSNumber对象<br>一对一关系—指针，指向单个复杂的对象。比如Employee中有一个指向Person实例的指针。<br>一对多关系—指针，指向某个collection类的实例，比如Person中又一个指向NSMutableArray的指针，该array中包含多个child</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Employee:<span class="keyword">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	int employeeID;</span><br><span class="line">	NSString *lastName;//对象属性</span><br><span class="line">	<span class="keyword">Person</span> *spouse;//一对一的关系</span><br><span class="line">	NSMutableArray *children;//一对多的关系</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>注意，对象只会保存其他对象的指针，而不是保存其他对象，可能会导致两个问题：<br>1.某个对象可能有多个角色，比如，其spouse还可能是多个child的紧急联系人<br>2.会导致产生大量独立的对象，耗尽可用内存，因此需要保留正在使用的对象，并释放那些不用的对象（内存回收）</p>
<h3 id="对象所有权与ARC（Automatic_Reference_Count,自动引用计数）">对象所有权与ARC（Automatic Reference Count,自动引用计数）</h3><p>MRC(手动引用计数，Manual Reference Count),与ARC相对应<br>当某个对象的拥有方个数为0，可以判定程序不在需要该对象，从而释放该对象。（“拥有方”可以理解为“被其他人拥有”，有其他对象内的指针指向该对象，如果拥有方个数为0，就表示不被任何人拥有，而自己拥有别人就无所谓）<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01L1tXDQUAo/yS30wEQ1Ovrm9k.jpg" alt="image"><br>上图中描述了简单的单向拥有关系，有以下几个：<br>1.最左边的NSMutableArray拥有多个Employee<br>2.每个Employee拥有多个Asset<br>3.每个Asset拥有一个NSString</p>
<p>对于这种情形，如果释放了NSMutableArray,则后续的所有对象都会被释放<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01zKSU37mYS/j9qVNJqlKV0A13.jpg" alt="image"><br>上图中描述了较复杂的双向拥有关系，除了上面提到的3点，还有1点：<br>1.每个Asset对象拥有各自的Employee，指向其对应的Employee对象</p>
<p>对于这种情形，如果释放了NSMutableArray,凡是拥有Asset对象的Employee对象都没有释放，因为虽然Employee对Asset的拥有关系消失了，但是Asset还对对应的Employee对象存在拥有关系，只有拥有方不为0，就不会自动释放。这就叫<code>retain循环</code>，是造成内存泄露的常见原因。</p>
<p>为了保证两个对象有一一对应的双向拥有关系，需要注意建立这种关系的时机（假设一个为父对象，一个为子对象）(—OC编程(2nd),chap20,避免内存泄露)</p>
<p>1.显式地设置这两个双向的关系,分别单独调用其设置关系的方法<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[father <span class="function"><span class="keyword">method</span>:</span>child]</span><br><span class="line">[child <span class="function"><span class="keyword">method</span>:</span>father]</span><br></pre></td></tr></table></figure></p>
<p>2.在为子对象设置指向父对象的指针时，同时设置父对象对子对象的拥有关系<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//child <span class="keyword">method</span></span><br><span class="line">-(<span class="type">void</span>) <span class="keyword">method</span>:(<span class="type">Fathertype</span> father)</span><br><span class="line">&#123;</span><br><span class="line">	holder = father;//为子对象设置指向父对象的指针</span><br><span class="line">	[father <span class="keyword">method</span>:self];//设置父对象对子对象的拥有关系，调用父对象的对应方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在为父对象设置对子对象的拥有关系时，同时设置子对象对父对象的拥有关系<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//father <span class="keyword">method</span></span><br><span class="line">-(<span class="type">void</span>)<span class="keyword">method</span>:(<span class="type">ChildType</span> c)</span><br><span class="line">&#123;</span><br><span class="line">	child = c;//为父对象设置对子对象的拥有关系</span><br><span class="line">	[c <span class="keyword">method</span>:self];//设置子对象对父对象的拥有关系,调用子对象的对应方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="如何分析内存泄露问题">如何分析内存泄露问题</h3><p>性能分析（profile） &amp; 性能分析工具（Instruments)—todo</p>
<h3 id="如何解决retain循环问题">如何解决retain循环问题</h3><h4 id="weak修饰符_与_strong修饰符">weak修饰符 与 strong修饰符</h4><p><code>strong</code> : 对于这个指针指向的对象，需要主张所有权，即必须要有人指向他，拥有它。<code>如下面的例子，就表示Asset对象对NSString对象有拥有权。**</code>当没有人拥有它时，这个label指向的NSString对象就可以释放。释放时，会收到dealloc信息（从NSObject继承），可以覆盖此dealloc方法。</p>
<p><code>__weak</code>:通过弱引用，可以解决<code>retain循环</code>问题。弱引用不主张所有权,如下面的例子，就表示Asset对象对holder没有拥有权,也就是说我们的Asset对象不会对其Employee对象存在拥有权，因此删除Employee对象的时候，所有对象都可以安全释放。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Employee</span>;   </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Asset</span> : <span class="title">NSObject</span> </span></span><br><span class="line">&#123;     </span><br><span class="line"><span class="built_in">NSString</span> *label;     </span><br><span class="line">__<span class="keyword">weak</span> Employee *holder;  <span class="comment">//__weak修饰符，不主张所有权，也就是说Asset不会对它所对应的Employee对象存在拥有权   </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> resaleValue; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *label; <span class="comment">//strong修饰符，必须主张所有权,也就是说这个Asset对象对NSString对象存在拥有权</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) Employee *holder; <span class="keyword">@property</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> resaleValue; <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果对象间是父子关系，那么为了避免retain循环，通常需要遵守规则：父对象拥有子对象，但是子对象不能拥有父对象</p>
</blockquote>
<h4 id="弱引用的自动清零特性">弱引用的自动清零特性</h4><p>为什么可以解决“retain循环”问题？<br>当某个由弱引用指向的对象被释放时，相应的指针变量会被归零，即赋为nil。</p>
<h4 id="MRC(手动引用计数)">MRC(手动引用计数)</h4><p>参考C++中得智能指针，同时参考<a href="(http://www.pchou.info/ios/2015/06/05/oc-memory-management.html">网页资料</a>)来理解reference count<br>可以理解为一个对象本身有一个引用计数的成员变量。当创建一个对象时，用一个指针指向这个对象。<br>oc中，如果新建一个对象并赋值，则这个对象初始化为1，只有retain,release操作可以改变引用计数的值。<br>如果调用retai，则会+1，<br>如果调用release，则会-1，<br>如果最后为0，则会自动释放该内存</p>
<p>下面解释书中例子<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动管理引用计数</span></span><br><span class="line"><span class="comment">//假设这里newEmp指向了一个Employee对象，这里需要设置holder也指向他</span></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setHolder:</span>(Employee *)newEmp </span><br><span class="line">&#123;     </span><br><span class="line">	[holder release]; <span class="comment">//原来holder可能有指向一个对象，这里需要先解除这个指向关系，也就是原来被指向的对象的拥有者先减少，也就是原来的对象的引用计数减少</span></span><br><span class="line">	[newEmp retain];  <span class="comment">//因为holder需要指向新的对象，也就是newEmp指向的对象，因此这个对象多了一个拥有者，因此引用不过计数需要增加</span></span><br><span class="line">	holder = newEmp; <span class="comment">//将holder指向新的一个Employee对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)dealloc </span><br><span class="line">&#123;     </span><br><span class="line">	[label release];   <span class="comment">//需要解除label的引用计数，以便自动释放内存  </span></span><br><span class="line">	[holder release];  <span class="comment">//需要解除holder对应关系，因此指向对象的引用计数需要-1</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://d.pcs.baidu.com/thumbnail/ba68bf5c4481babf34fba692d8ff93a9?fid=604950169-250528-435242864476861&amp;time=1437066000&amp;rt=pr&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-%2bHiwaKhovsC%2fTXFDHBMyUglqfPw%3d&amp;expires=8h&amp;prisign=unknow&amp;chkbd=0&amp;chkv=0&amp;size=c10000_u10000&amp;quality=90" alt="image"></p>
<h4 id="autorelease—todo">autorelease—todo</h4><p>会在将来的某个时候收到release消息<br>什么时候收到release消息？当autorelease池（对象）被排干（drain）的时候</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSString</span> *)description &#123;     </span><br><span class="line">	<span class="type">NSString</span> *<span class="literal">result</span> = [[<span class="type">NSString</span> alloc] initWithFormat:@<span class="string">"&lt;%@: $%d &gt;"</span>,                                             [self label], [self resaleValue]];     </span><br><span class="line">	[<span class="literal">result</span> autorelease];     </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建autorelease池（对象） </span><br><span class="line"><span class="type">NSAutoreleasePool</span> *arp = [[<span class="type">NSAutoreleasePool</span> alloc] init]; </span><br><span class="line"><span class="type">Asset</span> *asset = [[<span class="type">Asset</span> alloc] init];   </span><br><span class="line"><span class="type">NSString</span> *d = [asset description]; // d指针指向的<span class="type">NSString</span>对象已经在autorelease池中 </span><br><span class="line">[arp drain]; // description方法所返回的<span class="type">NSString</span>对象会收到release消息</span><br></pre></td></tr></table></figure>
<p>虽然ARC会自动使用autorelease池，但是必须由程序创建并排空相应的autorelease池，如果开启了ARC极致，也加入了创建autorelease池的语法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建autorelease池（对象） </span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;     </span><br><span class="line">	Asset *asset = [[Asset alloc] init];     </span><br><span class="line">	<span class="built_in">NSString</span> *d = [asset description];     <span class="comment">// d指针指向的NSString对象已经在autorelease池中 </span></span><br><span class="line">&#125; <span class="comment">// autorelease池已经被排空</span></span><br></pre></td></tr></table></figure>
<h4 id="retain计数规则">retain计数规则</h4><p>规则如下：（假设，“你”—“当前正在使用的某个类实例”）</p>
<ul>
<li>如果创建对象的方法名是alloc或new开头，或包含copy，则你已经得到了该对象的所有权（retain计数=1，而且该对象不在NSAutoReleasePool对象中）。你负责在不需要的时候释放。常见的会传输所有权的方法:alloc(跟一个init), copy, MutableCopy</li>
<li>其他途径创建的对象（便捷方法—todo？？？），你是没有所有权的（retain计数是1，而且在NSAutoReleasePool中，如果没有保留该对象，则当NSAutoReleasePool被drain时，对象自动释放）</li>
<li>如果不拥有某个对象，但是期望他继续存在，则可以发送retain消息来获取所有权</li>
<li>如果拥有某个对象并且不在需要使用时，可以发送release/autorelease消息。autorelease消息会导致：当NSAutoReleasePool被drain时，再向相应对象发送release消息</li>
<li>只要至少有一个拥有方，就会继续存在，当ratain计数=0，则会受到dealloc消息，自动释放</li>
</ul>
<blockquote>
<p>从局部的角度来看问题</p>
</blockquote>
<hr>
<h2 id="Collection类">Collection类</h2><h3 id="NSArray/NSMutableArray">NSArray/NSMutableArray</h3><h4 id="拥有权问题">拥有权问题</h4><p>将某个对象加入数组对象，则数组对象会成为该对象的拥有方；将某个对象移出数组对象，数组对象就会放弃该对象的所有权。init也叫初始化方法，类似于c++中得构造函数，构造函数可以因为参数不同有很多个，初始化方法也类似。</p>
<h4 id="可修改版本_vs-_不可修改版本">可修改版本 vs. 不可修改版本</h4><p>NSArray初始化：</p>
<ul>
<li>必须以nil结尾，一边知道数组个数</li>
<li>优点：<ul>
<li>保证数组内容“安全”，不可修改</li>
<li>性能考虑：不可修改对象永远无须拷贝。NSArray的copy方法仅返回指向自身的指针，而NSMutableArray的copy方法则会制作一份自己的拷贝，并返回指向新数组对象的指针</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *colors = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Orange"</span>, <span class="string">@"Yellow"</span>, <span class="string">@"Green"</span>, <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h4 id="排序">排序</h4><p>排序描述对象（sort descriptors）,每个对象有一个<code>key属性</code>和<code>ascending属性</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">NSMutableArray</span>方法</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">sortUsingDescriptors</span>:<span class="value">(NSArray *)sortDescriptors</span></span>;</span><br></pre></td></tr></table></figure>
<p>为何参数是一个数组？<br>比如对人名排序，先按姓氏排序，如果姓氏相同，按名称升序排列，如果都相同，可按zipcode排序<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01WkDsKkoF0/lzNVd33YaxR8IS.jpg?thumb=256x&amp;scale=auto" alt="image"></p>
<h4 id="过滤">过滤</h4><p>NSPredicate类，其对象可以包含一条语句，其运算结果可以为“真”或“假”,详细可以阅读扩展文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pUsing.html" target="_blank" rel="external">Predicate Programming Guide</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span>方法</span><br><span class="line">- (<span class="keyword">void</span>)filterUsingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line"><span class="built_in">NSArray</span>方法</span><br><span class="line">- (<span class="built_in">NSArray</span> *)filteredArrayUsingPredicxate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line"></span><br><span class="line">例子：创建predicate对象，并应用于allAssets数组对象，结果是返回满足predicate条件的所有数组元素，其条件就是对数组元素分别进行<span class="string">"holder.valueOfAssets &gt; 70"</span>这样的判断</span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"holder.valueOfAssets &gt; 70"</span>];         <span class="built_in">NSArray</span> *toBeReclaimed = [allAssets filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h3 id="NSSet/NSMutableSet">NSSet/NSMutableSet</h3><h4 id="概念">概念</h4><p>里面的对象<code>无序，唯一</code>，最大用处是检查某个对象是否存在<br>eg.员工可以有多个物品，但是某个物品只属于一个员工，因此可以用NSMutableSet带起NSMutableArray来管理assets<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01ENpE0PFLz/gC5OdYei6BOFt7.jpg" alt="image"></p>
<h4 id="访问">访问</h4><p>因为无序，所以不能以索引来访问，使用特殊的方法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">containsObject</span>:<span class="value">(id)x</span></span>;</span><br></pre></td></tr></table></figure>
<p>当收到这个消息时，会查找set对象中和x相等的对象。<br>“相等”—就是”isEqual:”方法<br>可以重写这个方法，定义自己的“相等”比较<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *x = ...;</span><br><span class="line"><span class="built_in">NSString</span> *y = ...;</span><br><span class="line">如果x和y的地址一样，则称“相同”</span><br><span class="line">如果x和y指向的对象完全一样，则称“相等”</span><br><span class="line">“相同”一定“相等”，而“相等”不一定“相同”</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObject:(<span class="keyword">id</span>)anObject;<span class="comment">//发送“isEqual:”消息，检查是否“相等”</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObjectIdenticalTo:(<span class="keyword">id</span>)anObject;<span class="comment">//用“==”运算符，检查是否“相同”</span></span><br></pre></td></tr></table></figure></p>
<h3 id="NSDictionary/NSMutableDictionary">NSDictionary/NSMutableDictionary</h3><h4 id="概念-1">概念</h4><p>以NSString对象为索引，是键值对的集合（key-value），也是无序的<br>分别以“CEO”，“CTO”为key建立Dictionary对象<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01xD3EqUIjp/N1RnV8V0gR8SLK.jpg" alt="image"></p>
<h3 id="collection类相关">collection类相关</h3><h4 id="C语言基本类型">C语言基本类型</h4><p>collection对象只能保存对象，如果需要保存float，int，指针等变量，需要先把这些c语言基本类型封装为对象，再存入collection对象。<br>NSNumber—保存数字类型<br>NSValue—保存指针和部分特定的结构类型</p>
<h4 id="nil">nil</h4><p>collection对象不能保存nil，如果确实需要加入，可以使用NSNull类，该类只有一个实例，代表空。NSArray初始化时再末尾加入nil，知识用来标记数组的结尾。</p>
<hr>
<h2 id="常量">常量</h2><p>定义常量两种方法：<code>#define,全局变量</code></p>
<h4 id="预处理指令：#include,_#import,_#define">预处理指令：<code>#include, #import, #define</code></h4><p><code>#import</code>:会确保预处理器值导入特定文件一次<br><code>#include</code>:允许多次导入同一个文件<br>为了简化文件导入并加快便以速度，引入<code>预编译文件xxx.pch</code></p>
<h4 id="全局变量">全局变量</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocale</span> *here = [<span class="built_in">NSLocale</span> currentLocale];         </span><br><span class="line"><span class="built_in">NSString</span> *currency = [here objectForKey:<span class="string">@"currency"</span>]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Money is %@"</span>, currency); </span><br><span class="line"><span class="comment">//上面个方法输入@"currency"不是很好，可用全局变量来替换</span></span><br><span class="line"><span class="built_in">NSLocale</span><span class="variable">.h</span>中声明</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *<span class="built_in">NSLocaleCurrencyCode</span>;</span><br><span class="line"><span class="built_in">NSLocale</span><span class="variable">.m</span>中定义</span><br><span class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *<span class="built_in">NSLocaleCurrencyCode</span> = <span class="string">@"currency"</span>; </span><br><span class="line">可以方便的使用，而且不会有输错得情况发生，xcode会自动补全</span><br><span class="line"><span class="built_in">NSString</span> *currency = [here objectForKey:<span class="built_in">NSLocaleCurrencyCode</span>];</span><br></pre></td></tr></table></figure>
<h4 id="enum">enum</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">typedef</span> enum  &#123;     </span><br><span class="line">	<span class="keyword">BlenderSpeedStir, </span>    </span><br><span class="line">	<span class="keyword">BlenderSpeedChop, </span>    </span><br><span class="line">	<span class="keyword">BlenderSpeedLiquify, </span>    </span><br><span class="line">	<span class="keyword">BlenderSpeedPulse, </span>    </span><br><span class="line">	<span class="keyword">BlenderSpeedIceCrush </span>&#125; </span><br><span class="line"><span class="keyword">BlenderSpeed;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义常量时，最好使用全局变量和enum，而不是#define</p>
</blockquote>
<h2 id="NSString和NSData，文件">NSString和NSData，文件</h2><h3 id="NSString对象与文件">NSString对象与文件</h3><p>需要注意字符串编码，UTF-8</p>
<h4 id="NSString—&gt;文件">NSString—&gt;文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path          </span><br><span class="line">atomically:(<span class="built_in">BOOL</span>)useAuxiliaryFile            </span><br><span class="line">encoding:(<span class="built_in">NSStringEncoding</span>)enc     <span class="comment">//指定字符串编码，NSUTF8StringEncoding          </span></span><br><span class="line">error:(<span class="built_in">NSError</span> **)error  <span class="comment">//指针的指针，而且error对象一开是并没有被实例化，只有真正发生错误了才会创建error对象</span></span><br></pre></td></tr></table></figure>
<h4 id="文件—&gt;NSString">文件—&gt;NSString</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(instancetype)</span>initWithContentsOfFile:<span class="params">(<span class="variable">NSString</span> *)</span>path </span><br><span class="line">encoding:<span class="params">(<span class="variable">NSStringEncoding</span>)</span>enc </span><br><span class="line">error:<span class="params">(<span class="variable">NSError</span> **)</span>error</span></span><br></pre></td></tr></table></figure>
<h4 id="NSData—&gt;文件">NSData—&gt;文件</h4><p>NSData对象“代表”内存中某块缓冲区<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path </span><br><span class="line">options:(<span class="built_in">NSDataWritingOptions</span>)mask   <span class="comment">//可以指定操作原子性，NSDataWritingAtomic </span></span><br><span class="line">error:(<span class="built_in">NSError</span> **)errorPtr</span><br></pre></td></tr></table></figure></p>
<h4 id="文件—&gt;NSData">文件—&gt;NSData</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="params">(instancetype)</span>dataWithContentsOfFile:<span class="params">(NSString *)</span>path</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="回调">回调</h2><p>NSRunLoop类，对应的实例会持续等待，当特定事件发生时，就会触发回调，向相应的对象发送消息。<br>三种途径实现回调：</p>
<p>1.目标-动作（target-action）<br>：在制定的时刻触发事件，很多简单的用户界面控件（按钮，滑块）都采用“目标-动作”机制。“当x发生时，向指定的对象发送某个特定的消息”，接受消息的对象就是目标（target），而消息的选择器（selector）就是动作（action）<br>2.辅助对象（helper objects）<br>“当x发生时，向遵守相应协议的辅助对象发送消息”，<code>委托对象</code>（delegate）和<code>数据源</code>（data source）是常见的辅助对象<br>3.通告（Notification）<br>通告中心，在应用开始等待前，告知通告中心“某个对象正在等待某些特定的通告，当其中的通告出现时，向指定的对象发送特定的消息”。当x发生时，会向通告中心发布通告，然后由通告中心转发给正在等待该通告的对象。</p>
<p>回调规则：<br>1.当要向一个对象发送一个回调时，使用“目标-动作对”<br>2.当要向一个对象发送多个回调时，apple会使用符合相应协议的辅助对象（辅助对象（委托对象或者数据源）需要实现协议的部分或全部方法）<br>3.向多个对象发送回调时，使用“通告”</p>
<h3 id="目标-动作对">目标-动作对</h3><p>NSTimer对象使用的是目标-动作对机制。创建该对象时，要设定延迟、目标和动作。在指定的延迟时间后，该对象会向设定的目标发送指定的消息。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;   </span><br><span class="line"><span class="annotation">@interface</span> <span class="string">Logger :</span> NSObject </span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sayOuch:</span>(NSTimer *)t; </span><br><span class="line">- <span class="annotation">@end</span> </span><br><span class="line"></span><br><span class="line">Logger *logger = [[Logger alloc] init]; </span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">2.0</span></span><br><span class="line"><span class="string">target:</span>logger   <span class="comment">//target设为logger对象                                                         </span></span><br><span class="line"><span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">sayOuch:</span>)         <span class="comment">//action设置为logger的sayouch:方法                                                </span></span><br><span class="line"><span class="string">userInfo:</span>nil                                                          </span><br><span class="line"><span class="string">repeats:</span>YES]; </span><br><span class="line">[[NSRunLoop currentRunLoop] run];   <span class="comment">//循环等待</span></span><br></pre></td></tr></table></figure>
<h4 id="selector选择器">selector选择器</h4><p>向某个对象发送消息时，会沿着继承层次结构向上，直到某个类回应“我有与消息名称相匹配哦的方法”<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01hxkO9U2HD/DfIK8kdjajgjRd.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<p>方法的查询必须非常快速。如果使用方法的实际名称（可能会很长）进行查询，那么查询速度会很慢。为了提速，编译器会为每个其接触过的方法附上一个唯一的数字。运行时，程序使用的是这个数字，而不是方法名，因此上面的代码中需要指定 <code>selector:@selector(sayOuch:)         //action设置为logger的sayouch:方法</code><br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01NmnARRJ9h/VoDvuSAAxak0EU.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<h3 id="辅助对象">辅助对象</h3><p>比如NSURLConnection例子，其方法<code>sendSynchronousRequest:returningResponse:er-ror:</code>可从web服务器获取数据，但是获取数据时会<code>阻塞</code>该主线程，而且某些情况下可能无法实现回调，比如当web服务器要求提供用户名以及密码的时候，因此以<code>异步</code>的模式来使用：先要求NSURLConnection对象获取数据，然后等待回调，当发生（1）得到数据（2）web服务器要求认证信息（3）数据获取失败 这几种情况时，会触发回调。</p>
<p>怎样设置这样的回调？？？<br>为NSURLConnection对象设置一个辅助对象。当特定的事件发生时，该NSURLConnection对象会向辅助对象发送相应的消息。</p>
<p>具体是哪些消息？？？<br>Apple为NSURLConnection提供了一套协议（protocol）。<code>协议</code>是一系列方法声明，辅助对象可以根据协议实现相应的方法。</p>
<p>因此我们新建的辅助对象作为NSURLConnection的delegate（委托对象），需要实现部分或全部协议规定的方法，并在方法中定义自己的行为，比如保存从web服务器取回的数据。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__unused NSURLConnection *fetchConn = [[NSURLConnection alloc] <span class="string">initWithRequest:</span>request</span><br><span class="line"><span class="string">delegate:</span>logger    <span class="comment">//设置delegate对象，，特定事件发生时，就会向辅助对象（delegate也就是logger对象）发送相应的消息（符合协议的一些方法），也就是让logger调用对应的消息，因此logger中需要按照协议实现部分或全部方法</span></span><br><span class="line"><span class="string">startImmediately:</span>YES];</span><br></pre></td></tr></table></figure>
<h3 id="通告中心">通告中心</h3><p>将多个对象通过通告中心将自己注册为观察者（observer），当发生某个事件时，会向通告中心发送通告，再由通告中心将该通告转发给相应的观察者（观察者模式），也就是说对应的观察者需要实现对应的方法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">addObserver</span><span class="pseudo">:logger</span>   <span class="comment">//将自己注册到观察中心，成为观察者</span></span><br><span class="line"><span class="tag">selector</span>:@<span class="tag">selector</span>(<span class="attribute">zoneChange</span>:)    <span class="comment">//收到通告之后会转而向观察者发送这个消息</span></span><br><span class="line"><span class="tag">name</span><span class="pseudo">:NSSystemTimeZoneDidChangeNotification</span>    <span class="comment">//收到的通告名称，也就是说收到这个通告之后，通告中心会向logger这个观察者发送zoneChange：的消息</span></span><br><span class="line"><span class="tag">object</span><span class="pseudo">:nil</span>];</span><br></pre></td></tr></table></figure>
<h3 id="回调与对象所有权">回调与对象所有权</h3><blockquote>
<p>无论哪种类型的回调，如果代码编写有问题，都有可能使等待回调的对象得不到正确的释放</p>
</blockquote>
<p>有一些规则需要遵守：(各自对象释放的时候取消这种关联，也就是只需要管好自己的就行，否则管理太乱)<br>1.通告中心不拥有其下的观察者，如果将某个对象注册为观察器，那么通常应该在释放该对象时，将其移出通告中心</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span> 
{     
    <span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">removeObserver</span><span class="pseudo">:self</span>]; 
} 
</code></pre><p>2.对象不拥有其下的委托对象或数据源对象。如果某个新创建的对象是另一个对象的委托对象或数据源对象，那么该对象应该在其dealloc方法中取消相应的关联</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span> 
{     
    <span class="attr_selector">[windowThatBossesMeAround setDelegate:nil]</span>;     
    <span class="attr_selector">[tableViewThatBegsForData setDataSource:nil]</span>; 
}
</code></pre><p>3.对象不拥有其目标。如果某个新创建的对象是另一个对象的目标，那么该对象应该在其dealloc方法中将相应的目标指针赋为0</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span> 
{
     <span class="attr_selector">[buttonThatKeepsSendingMeMessages setTarget:nil]</span>; 
}
</code></pre><h3 id="协议">协议</h3><p>在“辅助对象“提到过协议。<br>eg，iOS进程用UITableView实例来显示数据，但是该对象本身并不包含要显示的数据，必须从其他对象获取，因此，必须告诉UITableView对象，谁是你要的对象，这个对象将扮演数据源的角色。</p>
<p>应该怎样指定某个对象，使之成为UITableView的数据源？使用协议（protocol）</p>
<p><code>协议</code>是一组方法声明，其中的部分方法是必需的（required），另一些则是可选的（optional）。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableView</span>的数据源协议是<span class="built_in">UITableViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDataSource</span> &lt;<span class="title">NSObject</span>&gt; </span></span><br><span class="line"><span class="comment">// UITableView对象的数据源必须实现以下方法 </span></span><br><span class="line"><span class="keyword">@required</span>    <span class="comment">//必须方法</span></span><br><span class="line">	...... </span><br><span class="line"><span class="keyword">@optional</span>    <span class="comment">//可选方法</span></span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line"><span class="comment">//使用时，只需要让对应的对象遵守这个协议就可以,这样TerrificViewController就可以作为UITableView的数据源</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TerrificViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">UITableViewDataSource</span>&gt; </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是在Logger.h中，并没有将Logger声明为遵守相应的协议。这是因为直到作者编写本书时，Apple也没有为NSURLConnection的委托对象提供正式的协议。因此该例子中并没有继承一个协议，而是直接实现了自己的方法</p>
</blockquote>
<hr>
<h2 id="property_list格式，以及实战iOS应用">property list格式，以及实战iOS应用</h2><h3 id="property_list">property list</h3><p>为了处理数据的需要，有时需要使用某种特定格式的文件，既可以有计算机读取，也便于人识别：属性列表（property list,xxx.plist文件,XML格式）可以有以下对象组成—NSArray,NSDictionary,NSString,NSData,NSDate,NSNumber</p>
<h3 id="MVC">MVC</h3><p>MVC（Model-View-Controller,模型-视图-控制器）是一种设计模式</p>
<ul>
<li>model,负责保存数据，并能让其他对象访问这些数据。NSString,NSDate,NSArray等</li>
<li>view,应用中可见的元素，知道如何在屏幕上画出自己，并能响应用户输入。能够看得见的就是view对象，包括UIView,UITableView,UITextView,UIButton等</li>
<li>controller，负责执行程序的逻辑功能，以连接和驱动应用的不同组成部分，可以处理事件，并能与其他对象协同工作。model与view之间没有之间关联，需要controller从中协调，任务繁重但关键。controller会接受某些对象发出的消息，并转发相应指令给其他对象，类似于委托的工作。</li>
</ul>
<p><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01ueSBKJz9V/fhvSo3gu5QC9qd.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<h3 id="原理解释">原理解释</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.main函数作用<br>（1）UIApplicationMain会创建UIApplication类的实例（单实例）<br>（2）根据第四个参数，创建相应的类实例并设置为应用的委托对象，该对象会收到各种应用委托消息。</p>
<p>2.main函数流程如何转到委托对象中？<br>启动时UIApplication实例会向委托对象发送<code>application:didFinishLaunchingWithOptions:</code>消息，因此AppDelegate必须继承<code>UIApplicationDelegate</code>协议（代码自动生成，前面那个方法属于这个协议），且AppDelegate中必须实现这个方法。而且，凡是需要在程序能够和用户交互前就完成的初始化工作，都应在这个方法中实现。</p>
<hr>
<h2 id="iOS应用_vs-_Mac应用">iOS应用 vs. Mac应用</h2><p>Cocoa Touch框架例子的类关系图 vs. Cocoa框架例子的类关系图<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01hAGre7xlG/S4K0l7J2FozTdL.jpg" alt="image"><br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01voHPRj21Y/8XirvYbOmdfdYa.jpg" alt="image"></p>
<p>1.iOS—Cocoa Touch框架,使用UITableView, UITextField, UIButton…<br>Mac—Cocoa框架,使用NSTableView, NSTextField, NSButton…<br>2.手写代码 vs. Interface Builder —todo<br>3.Cocoa应用是基于文档的应用，可同时打开多个任务列表。<br>4.Cocoa Touch框架基于文档Document（继承NSDocument），没有应用委托对象，而Cocoa框架则又应用委托对象AppDelegate。基于文档的应用，用户可以同时打开多个文档对象，所以运行时可以有多个 Document实例，而每个实例都有自己的表格视图、按钮、任务数组和窗口等。<br>5.IBOutlet,IBAction,告诉Xcode，相应的指针或动作方法会通过Interface Builder而不是写代码来建立关联。设置之后就会成为插座变量，会再第8点中，在弹出菜单中显示以便选择今儿建立关联。实际上这两个关键字没有真正的含义。<br>6.NSTableView对象其实是嵌套对象，包含NSScrollView,NSTableView,NSTableColumn对象。如果需要选中某个特定的对象，<code>ctrl+shift+左键单击</code><br>7.怎样自动调整窗口大小<code>autosizing</code>和相对位置？Xcode6中默认看不到，需要将file inspector中得auto layout关闭<br>8.如何创建关联关系？<code>ctrl+鼠标拖动</code>,其实目的就是为一些指针赋值，比如为按钮设置target，action；或者为某个NSTableView设置对应的datasource<br>9.既然作为NSTableView的数据源，就需要实现其对应的协议的部分方法。比如修改条目时内容变化进而保存数据。<br>10.保存文档，载入文档的数据处理</p>
<hr>
<h2 id="OC高级主题">OC高级主题</h2><h3 id="init">init</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[NSMutableArray alloc]</span> init]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>aloc负责分配对象空间，init负责对象空间的初始化。init是实例方法，而alloc是类方法。</p>
<h4 id="推荐的init写法">推荐的init写法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="keyword">init</span> &#123;     </span><br><span class="line">	<span class="comment">// 调用NSObject的init方法     </span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];       </span><br><span class="line">	<span class="comment">// 父类的init方法的返回值是否为非nil?     </span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;         </span><br><span class="line">		<span class="comment">//通过存取方法为voltage赋值</span></span><br><span class="line">		[<span class="keyword">self</span> segVoltage:<span class="number">120</span>];</span><br><span class="line">		<span class="comment">//直接赋值，两种方法都可以</span></span><br><span class="line">		voltage = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定初始化方法">指定初始化方法</h4><p><code>[[OwnedApplicnace Alloc] init];</code>初始化方法调用链<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01fOAX9ChTi/3M8r9fB0GFk0q5.jpg" alt="image"></p>
<p>编写初始化方法时，应该遵循以下规则：   </p>
<ul>
<li>规则1：如果某个类有多个初始化方法，那么应该由其中的一个方法来完成实际的任务，该方法称为<code>指定初始化方法</code>。其他的初始化方法都应该（直接地或间接地）调用指定初始化方法。  </li>
<li>规则2：指定初始化方法应该先调用父类的指定初始化方法，然后再对实例变量进行初始化.</li>
<li>规则3：如果某个类的指定初始化方法和父类的不同（这里指的是方法名不同），就必须覆盖父类的指定初始化方法，并调用新的指定初始化方法。   </li>
<li>规则4：如果某个类有多个初始化方法，就应该在相应的头文件中明确地注明，哪个方法是指定初始化方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Appliance类</span></span><br><span class="line"><span class="comment">//指定初始化方法，满足规则4</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn &#123;     </span><br><span class="line">	<span class="comment">// 规则2，调用NSObject的init方法 </span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];       </span><br><span class="line">	<span class="comment">// 规则2，为productName赋值         </span></span><br><span class="line">	[<span class="keyword">self</span> setProductName:pn];           </span><br><span class="line">	<span class="comment">// 为voltage赋初始值         </span></span><br><span class="line">	[<span class="keyword">self</span> setVoltage:<span class="number">120</span>];     	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125; </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> initWithProductName:<span class="string">@"Unknown"</span>]; </span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line"><span class="comment">//OwnedAppliance类</span></span><br><span class="line"><span class="comment">//指定初始化方法，规则4</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn</span><br><span class="line">firstOwnerName:(<span class="built_in">NSString</span> *)n &#123;</span><br><span class="line">	<span class="comment">//调用父类的初始化方法</span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> initWithProductName:pn];       </span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;         </span><br><span class="line">		<span class="comment">// 创建NSMutableSet实例，用于保存拥有者的姓名         </span></span><br><span class="line">		ownerNames = [[<span class="built_in">NSMutableSet</span> alloc] init];           </span><br><span class="line">		<span class="comment">// 传入的第一个拥有者姓名是否为nil？         </span></span><br><span class="line">		<span class="keyword">if</span> (n) &#123;             </span><br><span class="line">			[ownerNames addObject:n];         </span><br><span class="line">		&#125;     </span><br><span class="line">	&#125;     </span><br><span class="line">	<span class="comment">// 返回指向新对象的指针     </span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn &#123;    </span><br><span class="line">	<span class="comment">//规则3，调用新的指定初始化方法 </span></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> initWithProductName:pn firstOwnerName:<span class="literal">nil</span>]; </span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line">[[OwnedAppliance alloc] init];</span><br><span class="line"><span class="comment">//Q：上面这个方法是否可以正确的初始化实例？是否需要实现init方法？</span></span><br><span class="line"><span class="comment">//A: 可以正确初始化，不需要覆盖实现init方法。因为没有实现init，因此上述调用会根据调用链找父类的init方法，而父类的init方法中的有`[self initWithProductName:@"Unknown"]`局域，其中self指向的时OwnedAppliance实例（多态），所以调用OwnedAppliance的`initWithProductName:`方法，今儿调用自己的指定初始化方法`initWithProductName:firstOwnerName:`;而指定初始化方法调用了super的指定初始化方法`initWithProductName:`，而父类的这个方法最后又调用了NSObject得init方法.</span></span><br></pre></td></tr></table></figure>
<h4 id="禁用init方法">禁用init方法</h4><p>上面的方法带有默认实参，比如Appliance的init方法付过不指定名称会以“Unknown”作为默认参数，但如果我们必须要求一个有效值时怎么处理比较好？覆盖父类的指定初始化方法，告知程序员不能使用这个方法，并提供修改建议(<code>抛出异常</code>—todo)。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (id)<span class="tag">init</span> &#123;     </span><br><span class="line">	<span class="variable">@throw</span> [NSException <span class="attribute">exceptionWithName</span>:@<span class="string">"WallSafeInitialization"</span>                                    	<span class="attribute">reason</span>:@<span class="string">"Use initWithSecretCode:, not init"</span>                                  	<span class="attribute">userInfo</span>:nil]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="属性">属性</h2><h3 id="属性的特性">属性的特性</h3><p>属性的特性可以控制如何创建存取方法<br>分类：<br>按存取类型：<br>rewrite(默认), readonly<br>按生命周期类型分(决定存方法如何处理与其相关的内存管理问题)：<br>unsafe_unretained：默认，而且非对象类型的实例变量应该使用这个特性  —针对非对象类型<br>strong：保留传入的对象，并放弃原有对象（如果原有对象不再有其他拥有方就会被释放），凡是指向对象类型的实例变量通常应该用此特性。   —针对对象类型<br>weak：不保留传入的对象，相应的存方法会将传入的对象直接赋给实例变量。如果该对象被释放，相应的实例变量会被自动赋为nil   —针对对象类型<br>copy：要求拷贝传入的对象，并将新对象赋给实例变量。—针对对象类型</p>
<h4 id="copy—todo">copy—todo</h4><p>[不可变对象 copy],返回相同不可变对象<br>[不可变对象 mutableCopy],返回新的可变对象<br>[可变对象 copy],返回新的不可变对象<br>[可变对象 mutalbeCopy],返回新的可变对象（<a href="http://my.oschina.net/aofe/blog/266677" target="_blank" rel="external">OC中copy得使用</a>）</p>
<h4 id="atomic/nonatomic">atomic/nonatomic</h4><p>适用于多线程编程范畴。一般属性默认为atomic，因此需要手动加上nonatomic</p>
<p><code>(readwrite, copy, nonatomic)</code></p>
<h3 id="KVC(key-value_coding)">KVC(key-value coding)</h3><p>KVC（key-value coding）能够让程序通过名称直接存取属性。因为与KVC有关的方法都是在NSObject中定义的，所以凡是继承自NSObject的类都具备KVC功能。<br><code>setValue:forKey:</code>方法,会查找名为<code>setProductName:</code>的存方法（set-Value:forKey:方法是在NSObject中定义的）.如果没有setProductName:方法，直接为实例变量赋值。</p>
<p><code>valueForKey:</code>方法,会查找名为<code>productName:</code>的取方法（valueForKey:方法是在NSObject中定义的）。如果对象没有productName:方法，就会直接返回相应的实例变量。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[a <span class="string">setProductName:</span>@<span class="string">"Washing Machine"</span>];</span><br><span class="line">[a <span class="string">setValue:</span>@<span class="string">"Washing Machine"</span> <span class="string">forKey:</span>@<span class="string">"productName"</span>];</span><br><span class="line">NSLog(@<span class="string">"the product name is %@"</span>, [a productName]);</span><br><span class="line">NSlog(@<span class="string">"the product name is %@"</span>, [a <span class="string">valueForKey:</span>@<span class="string">"productName"</span>]);</span><br><span class="line"><span class="comment">//对于非对象类型，需要先转化为对象类型，比如int--&gt;NSNumber</span></span><br><span class="line">[a <span class="string">setVoltage:</span><span class="number">240</span>];</span><br><span class="line">[a <span class="string">setValue:</span>[NSNumber <span class="string">numberWithInt:</span><span class="number">240</span>] <span class="string">forKey:</span>@<span class="string">"voltage"</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么需要KVC？<br>当Apple提供的框架需要向读者编写的对象写入数据时，会使用setValue:forKey:方法<br>当Apple提供的框架需要从读者编写的对象读取数据时，会使用valueForKey:方法<br>Core Data框架为例（Core Data框架能够将对象保存在SQLite数据库中，并在需要时将其还原成对象），这套框架会通过KVC来管理自定义的数据对象。</p>
</blockquote>
<hr>
<h2 id="高级主题">高级主题</h2><h3 id="范畴">范畴</h3><p>使用范畴（category），程序员可以为任何已有的类添加方法。比如可以为NSString添加一个方法VowelCount，用来计算字符串中得元音个数。（<a href="http://jingyan.baidu.com/article/3c343ff7efd4860d377963cd.html" target="_blank" rel="external">xcode6如何创建category文件？</a>）<br>如果需要在其他程序中使用vowelCount方法，需要将相应的实现文件加入项目，并在构建程序时将范畴编译进去。</p>
<h3 id="block对象">block对象</h3><p>block对象可以理解为函数指针/匿名函数/closure/lamda。</p>
<h4 id="block对象声明，定义，使用">block对象声明，定义，使用</h4><p>可以没有函数名，但为了能够通过名称使用某个block对象，需要赋给block对象变量。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明Block变量         </span></span><br><span class="line"><span class="keyword">void</span> (^devowelizer)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *); </span><br><span class="line"><span class="comment">// 定义block变量</span></span><br><span class="line">devowelizer = ^(<span class="keyword">id</span> string, <span class="built_in">NSUInteger</span> i, <span class="built_in">BOOL</span> *stop) &#123; ...&#125;</span><br><span class="line"><span class="comment">// 使用block变量</span></span><br><span class="line"><span class="comment">// 枚举数组对象oldStrings，针对每个数组中的对象，执行Block对象devowelizer         </span></span><br><span class="line">[oldStrings enumerateObjectsUsingBlock:devowelizer];</span><br></pre></td></tr></table></figure></p>
<h4 id="typedef">typedef</h4><p>与函数指针类似，可以用typedef来简化书写方式,定义了一个类型，而不是变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ArrayEnumerationblock)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *);</span><br><span class="line">ArrayEnumerationBlock devowelizer;</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">void</span>(^devowelizer)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *);</span><br></pre></td></tr></table></figure></p>
<h4 id="内存管理—todo">内存管理—todo</h4><p>基于栈的block对象,当创建block的函数或者方法完成执行并范湖ihou，相应的block对象会随着栈帧的释放而被释放。<br>基于堆的block对象</p>
<p>向block对象发送copy消息，可以将其从栈拷贝至堆。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayEnumerationBlock iVarDevowelizer = [devowelizer <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>那些由Apple提供的并且支持Block对象的方法，例如NSArray的enumerateObjectsUsing-Block:，或者NSNotificationCenter的addOb-serverForName:object:queue:usingBlock:，都会拷贝传入的Block对象，并将其保存在堆中。通过拷贝Block对象，这些方法得以创建指向保存于堆中的Block对象的指针（并且是strong特性的引用）。</p>
</blockquote>
<p>几点需要注意：—todo<br>1.对于block对象使用的变量，程序如何管理其生命期？<br>block对象中通常会使用外部创建的变量，执行block对象时，为了确保外部变量始终存在，相应的block对象会捕获这些变量。什么时候捕获呢？在将基于栈的block对象拷贝至基于堆得block对象的时候。<br>对于基本类型的变量，捕获意味着拷贝变量的值，并用block对象内的局部变量保存。对于指针类型的变量，block对象会用strong特性的引用，也就是说block对象用到的对象都会保留，所以在相应block对象释放前，这些对象一定不会被释放。</p>
<p>2.这类strong特性引用会导致retain循环问题吗？<br>有可能。当block对象所使用的对象保留了当前的block对象时。解决方法：现在block对象外声明一个__weak指针，然后将这个指针指向block对象的使用的对象，最后在block中使用这个新的对象。</p>
<p>3.可以修改block对象所拷贝的变量码？<br>被捕获的变量是常数，程序无法修改变量所保存的值。如果是指针，则不可修改指针，但是可以修改指针指向的对象。<br>如果需要在block对象内修改外部变量，可以在声明外部变量时，在前面加上<code>__block</code>.</p>
<hr>
<h2 id="其他">其他</h2><ul>
<li>xcode6如何创建空的Empty Application? 很多书特别是翻译过来的书，里面使用的环境较老，会有empty application的类型可以选择，但是新的xcode6里面就没有，需要按照下面的方法自己新建<a href="http://blog.csdn.net/ayaseeli/article/details/41725923" target="_blank" rel="external">—链接</a></li>
</ul>
<ul>
<li><code>#pragma mark --some comemnts</code>,当某个类有很多方法的时候，可以使用这个指令来帮助快速分类并定位.</li>
</ul>
<p>xcode快捷方式<br>自动补全，主题，颜色。。。</p>
<h1 id="Ref：">Ref：</h1><ul>
<li><a href="http://www.coderyi.com/archives/397" target="_blank" rel="external">ios开发路线简述</a></li>
<li><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="external">ios学习资料整理—github</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C(官网)</a></li>
<li><a href="http://cocoadevcentral.com/d/learn_objectivec/" target="_blank" rel="external">快速入门</a></li>
<li><a href="http://code.taobao.org/p/iOSProgramming/src/Chapter2/RandomItems/" target="_blank" rel="external">taobao网上得课程代码</a></li>
<li><a href="http://blog.csdn.net/wishfly/article/details/7384708" target="_blank" rel="external">Objective-C内存布局—描述isa指针是什么</a></li>
</ul>
<h1 id="todo">todo</h1><ul>
<li>ios4th</li>
<li>性能分析工具</li>
<li>iOS Simulator使用</li>
<li>实例练习</li>
<li>开源项目</li>
<li>搞起</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>oc以c语言为基础，加入了对面向对象编程（OOP）的支持。</p>
<p>工具：xcode6</p>
<p>书籍：《Objective-C编程》—Aaron Hillegass[美]</p>
<h2 id="变量与类型">变量与类型</]]>
    </summary>
    
      <category term="ios" scheme="http://shawnelee88.github.io/tags/ios/"/>
    
      <category term="oc" scheme="http://shawnelee88.github.io/tags/oc/"/>
    
      <category term="ios" scheme="http://shawnelee88.github.io/categories/ios/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo建站记录]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/hexo%E8%AE%B0%E5%BD%95-md/"/>
    <id>http://shawnelee88.github.io/2015/07/09/hexo记录-md/</id>
    <published>2015-07-09T14:18:06.000Z</published>
    <updated>2015-07-19T03:20:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hexo记录">hexo记录</h1><p>准备工作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">hexo <span class="keyword">server</span></span></span><br></pre></td></tr></table></figure>
<p>主要命令：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span> <span class="preprocessor">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span> <span class="preprocessor">#新建页面</span></span><br><span class="line">hexo generate <span class="preprocessor">#生成静态页面至public目录</span></span><br><span class="line">hexo <span class="keyword">server</span> <span class="preprocessor">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="preprocessor">#将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">localhost:<span class="number">4000</span> 本地查看</span><br></pre></td></tr></table></figure>
<p>安装中可能出现的错误</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/default/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Debug/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/hexojs/hexo-cli/issues/1" target="_blank" rel="external">解决方法</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>参考文章：</p>
<ul>
<li><a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li>atom + hexo</li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo官网</a></li>
<li><a href="http://akarin.xyz/build-your-hexo-blog/" target="_blank" rel="external">hexo静态博客使用指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[对hexo+github建站做个简单记录]]>
    
    </summary>
    
      <category term="github" scheme="http://shawnelee88.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://shawnelee88.github.io/tags/hexo/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
  </entry>
  
</feed>