<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Learn & Think]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://shawnelee88.github.io//"/>
  <updated>2015-09-07T15:25:35.000Z</updated>
  <id>http://shawnelee88.github.io//</id>
  
  <author>
    <name><![CDATA[搬砖的]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[vim记录]]></title>
    <link href="http://shawnelee88.github.io/2015/09/03/vim%E8%AE%B0%E5%BD%95/"/>
    <id>http://shawnelee88.github.io/2015/09/03/vim记录/</id>
    <published>2015-09-02T19:33:28.000Z</published>
    <updated>2015-09-07T15:25:35.000Z</updated>
    <content type="html"><![CDATA[<p>平台：MacOSX, MacVim</p>
<p>推荐插件：spf13-vim</p>
<h2 id="简介">简介</h2><ul>
<li>支持Vim，Gvim，MacVim</li>
<li>整洁，容易扩展，并且跨平台，易于安装维护</li>
<li>跨平台：Windows, Linux, *nix, MacOS</li>
<li>高度可定制：三个文件 ~/.vimrc.local, ~/.vimrc.bundles.local, ~/.vimrc.before.local</li>
</ul>
<h2 id="安装MacVim_&amp;_spf13">安装MacVim &amp; spf13</h2><p>为了让各种插件能正常工作，特别是<code>neocomplete</code>这个插件,需要安装特殊的MacVim版本：<a href="https://github.com/Shougo/neocomplete.vim#requirements" target="_blank" rel="external">Vim with lua</a><br>安装MacVim<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">brew</span> <span class="comment">install</span> <span class="comment">macvim</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">with</span><span class="literal">-</span><span class="comment">cscope</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">with</span><span class="literal">-</span><span class="comment">lua</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">HEAD</span></span><br></pre></td></tr></table></figure></p>
<p>安装spf13, Requires Git 1.7+ and Vim 7.3+<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http<span class="variable">s:</span>//<span class="keyword">j</span>.mp/spf13-vim3 -L &gt; spf13-<span class="keyword">vim</span>.<span class="keyword">sh</span> &amp;&amp; <span class="keyword">sh</span> spf13-<span class="keyword">vim</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<h2 id="如何使用">如何使用</h2><p>系统自带了3个文件：</p>
<ul>
<li>~/.vimrc</li>
<li>~/.vimrc.before</li>
<li>~/.vimrc.bundles</li>
</ul>
<p>对应如果需要修改，则在本地创建local版本</p>
<ul>
<li>~/.vimrc.local</li>
<li>~/.vimrc.before.local</li>
<li>~/.vimrc.bundles.local</li>
</ul>
<h3 id="三个文件分别是干嘛用的？看各个文件的notes">三个文件分别是干嘛用的？看各个文件的notes</h3><p>~/.vimrc:基本的配置信息</p>
<p>~/.vimrc.before文件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"   This file is for options which must be <span class="operator"><span class="keyword">set</span> *<span class="keyword">before</span>* plugins</span><br><span class="line"><span class="string">"   are loaded and the main .vimrc config is run. Most of these</span><br><span class="line">"</span>   <span class="keyword">are</span> <span class="keyword">for</span> preventing mappings <span class="keyword">or</span> commands <span class="keyword">from</span> being created.</span><br><span class="line">先导入的是<span class="keyword">before</span>文件中的配置信息，此文件中的信息一般是一些控制选项，需要在插件加载以及.vimrc</span><br><span class="line">加载之前导入到vim运行环境中。大多是用来禁止一些映射以及命令。</span><br><span class="line">.vimrc.<span class="keyword">before</span><span class="comment">--spf13自带，可参考，最好不修改</span></span><br><span class="line">.vimrc.<span class="keyword">before</span>.fork<span class="comment">--可以不用</span></span><br><span class="line">.vimrc.<span class="keyword">before</span>.<span class="keyword">local</span><span class="comment">--如果需要本地定制，在此文件中添加配置信息</span></span></span><br></pre></td></tr></table></figure></p>
<p>~/.vimrc.bundles文件<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"   This file imports the various plugins of spf13. If you</span><br><span class="line"></span><span class="string">"   wish to alter which groups are imported, see vimrc.before.</span><br><span class="line"></span><span class="string">"   If you wish to add or remove individual bundles, create</span><br><span class="line"></span><span class="string">"   ~/.vimrc.bundles.local and `Bundle` or `UnBundle` as needed</span><br><span class="line"></span><span class="string">"   from there.</span><br><span class="line"></span>然后导入bundles文件，里面是插件信息。其中有一个很重要的变量表示不同的使用用途或配置选项</span><br><span class="line">spf13_bundle_groups=[<span class="string">'general'</span>, <span class="string">'writing'</span>, <span class="string">'neocomplete'</span>, <span class="string">'programming'</span>, <span class="string">'php'</span>, <span class="string">'ruby'</span>, <span class="string">'python'</span>, <span class="string">'javascript'</span>, <span class="string">'html'</span>, <span class="string">'misc'</span>,]</span><br><span class="line">理论上这个配置应该在before文件中定义，而.vimrc.before中并没有定义，因此需要在.vimrc.before.local</span><br><span class="line">中自定义，而且还可以通过<span class="string">'Bundle'</span>,<span class="string">'UnBundle'</span>来添加或删除插件</span><br><span class="line">如果完全不需要bundles文件中的插件，而是自定义插件安装的话，则需要在.vimrc.before.local中添加</span><br><span class="line">配置选项`<span class="keyword">let</span> <span class="variable">g:override_spf13_bundles</span> = <span class="number">1</span>`</span><br></pre></td></tr></table></figure></p>
<p>添加或删除插件的例子<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.vimrc.bundles.local</span></span><br><span class="line">eg.</span><br><span class="line">Bundle <span class="string">'powerline/fonts'</span></span><br><span class="line">UnBundle <span class="string">'scrooloose/syntastic'</span></span><br><span class="line">再输入</span><br><span class="line">vim +BundleInstall! +BundleClean +<span class="tag">q</span></span><br><span class="line">如果vundle是最新版本，可以试试</span><br><span class="line">:PluginInstall</span><br><span class="line">vim +PluginInstall +qall</span><br></pre></td></tr></table></figure></p>
<h2 id="配置修改">配置修改</h2><p>自己设置Leader—;<br>修改所有leader—&gt;Leader<br>使用gundo代替undotree，设置</p>
<h2 id="插件介绍">插件介绍</h2><h3 id="Gundo代替Undotree">Gundo代替Undotree</h3><blockquote>
<p>visualize your Vim undo tree</p>
</blockquote>
<p>设置：.vimrc.local<br>nnoremap <leader>u :GundoToggle<cr></cr></leader></p>
<h3 id="NERDTree">NERDTree</h3><h2 id="推荐阅读：">推荐阅读：</h2><p><a href="http://feihu.me/blog/2014/intro-to-vim/" target="_blank" rel="external">跟我一起学习vim—the life changing editor</a></p>
<p><a href="https://github.com/yangyangwithgnu/use_vim_as_ide#2" target="_blank" rel="external">所需即所获：像 IDE 一样使用 vim</a></p>
<p><a href="http://vim.spf13.com/#vimrc" target="_blank" rel="external">官网</a><br><a href="https://github.com/spf13/spf13-vim" target="_blank" rel="external">Github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>平台：MacOSX, MacVim</p>
<p>推荐插件：spf13-vim</p>
<h2 id="简介">简介</h2><ul>
<li>支持Vim，Gvim，MacVim</li>
<li>整洁，容易扩展，并且跨平台，易于安装维护</li>
<li>跨平台：Wind]]>
    </summary>
    
      <category term="MacVim" scheme="http://shawnelee88.github.io/tags/MacVim/"/>
    
      <category term="杂记" scheme="http://shawnelee88.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[斯坦福大学公开课_iOS7开发]]></title>
    <link href="http://shawnelee88.github.io/2015/08/18/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%BC%80%E8%AF%BE-iOS7%E5%BC%80%E5%8F%91/"/>
    <id>http://shawnelee88.github.io/2015/08/18/斯坦福大学公开课-iOS7开发/</id>
    <published>2015-08-18T15:49:41.000Z</published>
    <updated>2015-09-08T15:54:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_Class_Logistics,_Overview_of_iOS,_MVC,_Objective-C">1. Class Logistics, Overview of iOS, MVC, Objective-C</h2><p>class1 schedule:</p>
<ul>
<li>What is this class all about?<ul>
<li>Description</li>
<li>Prerequisities</li>
<li>Homework/Final Project</li>
</ul>
</li>
<li>iOS overview<ul>
<li>What’s is iOS?</li>
</ul>
</li>
<li>MVC<ul>
<li>Object-Oriented Design Concept</li>
</ul>
</li>
<li>Objective-C<ul>
<li>(Time Permitting)</li>
<li>New Language!</li>
<li>Basic concepts only for today</li>
</ul>
</li>
</ul>
<h3 id="iOS_overview">iOS overview</h3><p>主要由这么几个部分：</p>
<ul>
<li>Core OS<ul>
<li>OSX Kernel, Mach 3.0, BSD, Sockets, Security, Power Management, Keychain Access, Certificates, File System, Bonjour(networking)</li>
</ul>
</li>
<li>Core Services<ul>
<li>Collections, Address Book, Networking, File Access, SQLite, Core Location, Net Services, Threading, Preferences, URL Utilities</li>
</ul>
</li>
<li>Media<ul>
<li>Core Audio, OpenAL, Audio Mixing, Audio Recording, Video playback, JPEG/PNG/TIFF, PDF, Quartz(2D), Core Animation, OpenGL ES</li>
</ul>
</li>
<li>Cocoa Touch<ul>
<li>Multi-Touch, Core Motion, View hierarchy, localization, controls, alerts, web view, map kit, image picker, camera</li>
</ul>
</li>
</ul>
<p>几个重要的框架Frameworks：</p>
<ul>
<li>Foundation:array, dictionary</li>
<li>UIKit: buttons, sliders</li>
<li>Core data: Object-oriedted database</li>
<li>Core motion: gyro and accelerometer(陀螺仪和加速器)</li>
<li>map kit</li>
</ul>
<h3 id="MVC(Model,_View,_Controller)">MVC(Model, View, Controller)</h3><h4 id="MVC是什么">MVC是什么</h4><p>将程序中各个部分进行分类，主要分为3个部分，MVC，不同部分对其他部分存在有限的访问权限，分层<br>的目的就是管理不同模块之间的通信。</p>
<blockquote>
<p>Model = What your app is(but not how it is displayed)</p>
<p>Controller = How your Model is presented to user(UI)</p>
<p>View = Your Controller’s minions</p>
</blockquote>
<h4 id="特征">特征</h4><p>Controller,可以无限制的直接访问Model以及view（controller中的一个指向view的指针，<br>也叫做outlet）; Model以及View永远不应该有通信,需要Controller做中介。</p>
<p>Q:view是否可以向controller发起通信？<br>A:一种“blind(view并不知道class的具体实现)”并且结构化的通讯方式，需要target-action回调<br>controller drop a target on itself<br>controller hand out an ‘action’ to the View<br>view sends the action when things happen in UI(press button…)</p>
<p>更复杂的情形，view中变化比较复杂的时候，controller需要知道发生了什么，需要保持同步<br>Q: view needs to synchronize with controller<br>A:委托（delegate）给controller， (will,should,did)<br>controller sets itself as the view’s delegate<br>delegate is set via a protocol<br>view无法分辨一些动作，需要将这个工作委托给controller来处理，识别是will,should,did</p>
<blockquote>
<p>protocol—a blind way to talk to another object</p>
</blockquote>
<p>更进一步<br>Q:view do not own the data they display<br>A:特殊的委托—data source（data,at,count）<br>controller are always that data source(not model)<br>controller interpret/format model information for view</p>
<p>Q:model需要同controller通信?<br>A:需要notification &amp; KVO(Key value observation)机制<br>类似于观察者模式，只有注册了之后，如果广播源发生了一下变化，这些注册了的家伙才能得到通知<br>(举广播站为例，广播站肯定不断在向外发送广播，而收听者只有调到对应的频段才能收到广播，也就是<br>加入了观察者的队列中了)</p>
<p>如果app越来越复杂，可能设计的scene越来越多，可能就需要混合使用MVC。<br>比如calendar，点击某个月，就会进入month view，再点击某个日期，就会进入day view</p>
<h3 id="Objective-C">Objective-C</h3><p>property<br>OC中不直接访问属性，而是通过”getter/setter”方法，”getter”方法通常与属性名相同(假设属性名<br>为myValue，则getter方法也为“myValue”)，而”setter”方法通常有个前缀“set”,且变量首字母<br>转换为大写(对应“setter”方法名为“setMyValue”)</p>
<p>xxx.h: public api<br>xxx.m: private api &amp; implementation</p>
<p>包含头文件需要注意的地方<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="preprocessor"><span class="keyword">import</span> &lt;Foundation/NSObject.h&gt;</span><br><span class="line">通常，C++的惯例来说，使用了某个类型才会包含其头文件，如上面的做法</span><br><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">但是经过优化，只需要包含整个框架文件，比较方便，便于编写</span><br><span class="line">@<span class="keyword">import</span> Foundation;</span></span><br><span class="line">iOS7以上，用上面更方便的方法,引入整个framework</span><br></pre></td></tr></table></figure></p>
<p>C语言中要求先声明再使用函数，OC中并不需要<br>OC中所有对象都存在于堆中，并用指针访问，因此新创建的对象返回的都是指针，不可能返回整个对象。<br>OC会自动分配并释放这些分配的内存。问题是它如何知道何时free？strong属性。<code>引用计数</code>为0，<br>即没有“strong”指针指向该对象，就会自动释放，不为0，即还有“strong”指针指向该对象，就会保<br>存在heap中。（参考oc基础那本书关于arc内容以及引用计数）所有指针要么是strong，要么是weak。<br>(这是reference counting，不是gc—todo)</p>
<blockquote>
<p>strong: keep the objects that this property points to in memory until I set this property to nil(zero)(and it will stay in memory until everyone who has a strong pointer to it sets their property to nil too)</p>
<p>weak: if no one else has a strong pointer to this object, then you can throw it out of memory and set this property to nil(this can happen at any time)</p>
</blockquote>
<p>其他语言中，不能对nil指针进行解引用，会导致程序崩溃；但是oc中可以想nil指针发送消息，只是<br>返回结果有所不同</p>
<p>多线程需要注意</p>
<blockquote>
<p>nonatomic: access to this property is not theaad-safe, we will always specify this for objects pointers in this course. If you do not, then the compoler will generate locking code that will complicate your code elsewhere.</p>
</blockquote>
<p>为何加这个nonatomic？跟iOS的多线程机制有关—todo</p>
<blockquote>
<p>gc vs. referenc counting—todo</p>
</blockquote>
<p>例子：纸牌匹配游戏</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_Class_Logistics,_Overview_of_iOS,_MVC,_Objective-C">1. Class Logistics, Overview of iOS, MVC, Objective-C</h2><p>class1 schedule:]]>
    </summary>
    
      <category term="OC" scheme="http://shawnelee88.github.io/tags/OC/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS_FAQ]]></title>
    <link href="http://shawnelee88.github.io/2015/07/30/IOS-FAQ/"/>
    <id>http://shawnelee88.github.io/2015/07/30/IOS-FAQ/</id>
    <published>2015-07-30T15:03:49.000Z</published>
    <updated>2015-07-30T15:03:49.000Z</updated>
    <content type="html"><![CDATA[<p>工具类</p>
<ul>
<li><a href="http://blog.csdn.net/ayaseeli/article/details/41725923" target="_blank" rel="external">xcode6如何创建空的Empty Application?</a></li>
<li><a href="http://jingyan.baidu.com/article/3c343ff7efd4860d377963cd.html" target="_blank" rel="external">xcode6如何创建category文件</a></li>
</ul>
<p>语言小知识</p>
<ul>
<li>asdf</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[关于工具以及iOS开发的一些小tips]]>
    
    </summary>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/tags/iOS/"/>
    
      <category term="oc" scheme="http://shawnelee88.github.io/tags/oc/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[斯坦福大学公开课程_iOS8开发]]></title>
    <link href="http://shawnelee88.github.io/2015/07/30/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%BC%80%E8%AF%BE%E7%A8%8B-iOS8%E5%BC%80%E5%8F%91/"/>
    <id>http://shawnelee88.github.io/2015/07/30/斯坦福大学公开课程-iOS8开发/</id>
    <published>2015-07-30T15:01:27.000Z</published>
    <updated>2015-08-09T03:04:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Lecture1-_Developing_Applications_for_iOS">Lecture1. Developing Applications for iOS</h2><p>从例子入手，视频讲解了一个Calculator的例子<br>1.创建project类型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iOS--single view application</span><br><span class="line">Product Name:Calculator</span><br><span class="line">Organization Name:zju</span><br><span class="line">Organization Identifier:io<span class="class">.github</span><span class="class">.shawnelee88</span></span><br><span class="line">Language:Swift</span><br><span class="line">Devices:<span class="function"><span class="title">universal</span><span class="params">(iPhone, iPad)</span></span></span><br><span class="line">core data: no <span class="function"><span class="title">need</span><span class="params">(not db oriented)</span></span></span><br></pre></td></tr></table></figure></p>
<p>创建好之后我们暂时只需要关注下面两个文件：ViewController.swift(act as Controller), Main.storyboard(act as View, UI), main.storyboard文件只关注界面显示以及按钮放置， 具体的控制交由ViewController.swift文件完成，比如点击“+”按钮，会进行加法运算，并将结果进行显示.<br>点击Main.storyboard进去就能看到一个方框，叫做场景scenes(represents kind of phone full of information)屏幕切换的时候涉及到， storyboard可能有多个secnes，以便管理不同屏幕切换</p>
<p>下面设计到具体的Calculator的设计<br>1.calculaor UI组成部分：一个文本框用来显示输入的数字以及运算结果，多个数字，多个运算符；各种按钮<br>2.label相关：</p>
<ul>
<li>放置控件时会出现蓝线，按蓝线对齐，后续autolayout会用到</li>
<li>label可调整大小，位置，编辑文本内容（文本初始写为0，文本字体，大小，颜色，对齐等也可编辑，我们选择右对齐）</li>
</ul>
<p>Q:做一定的设置之后直接运行，但是却看不到之前scene中的label中设置的“0”?</p>
<p>A:scene是方形的，而实际的iPhone设备是长方形的，比例不对，所以可能导致部分文字内容显示不对，因此需要autolayout</p>
<p>Q:那为什么UI中得scene设计为方形的呢？为啥不跟iPhone比例一致呢？</p>
<p>A:因为这种iOS界面设计，是将其他内容放在这个方形中，并给所有内容添加规则(rule)（当他们被压扁时会发生什么变化，根据不同的设备类型进行相应的水平或垂直变化），这些规则我们称之为约束（constraints）。因此这里可以理解为UI中需要考虑相对的变化趋势就可以，具体让UI根据不同设备尺寸自适应。</p>
<p>Q;如何添加规则限制?</p>
<p>A:1.比如需要将文本框设置为对齐右边界，则按住ctrl并拖动文本框向右，到达右边界之后释放拖动，会自动弹出菜单供选择<br>(1)trailling space to container margin—距离容器的右间距<br>(2)center vertically in container—使label垂直居中于这个容器<br>(3)equal widths—label的宽度与容器相同（不是我们想要的，我们需要留一点间距）<br>(4)equal heights<br>(5)aspect ratio—todo<br>之后会出现黄色或橙色的线，表示已经定义了规则，但是还不完整（因为暂时值定义了右边距）<br>,此需要确定完整的水平以及垂直方向的所有限制<br>2.左边界设置，左边距ctrl并拖动label向左，释放并弹出菜单<br>(1)leading space to container margin—距离容器的左边距<br>(2)(3)(4)(5)内容与上面相同<br>3.上边界设置<br>(1)top space to top layout guide (2)(3)(4)(5)<br>至此，水平防线就会出现蓝线，表示水平方向的已经完成,但是垂直方向还缺少下边框的设置。<br>4.下边界设置<br>比如我们希望按照我们文本的大小来设置，仍然会有橙色的告警，这是需要点击左下方的按钮（文档大纲，document outline）,<br>左下方有文档大纲按钮，如果还存在规则问题，会在树状目录顶端的“view Controller scene”右侧出现一个向右的箭头， 根据这个里面的具体提示进行修改<br>(1)update frame—根据我们的设置进行constras设置，常用<br>(2)update constraints—使用当前设置,force constraints,不常用<br>(3)reset to suggested constraints—会把constraints与蓝线重合，可以用<br>完了之后就完全与蓝线重合，运行模拟器，无论对窗口如何旋转，label的”0”都能正确显示在右上方<br>这就是<code>autolayout</code>的部分概念</p>
<p>Q:规则冲突或有问题怎么解决？如何取消规则？</p>
<p>A:也可以按照上面的方法根据提示来解决规则冲突的问题。</p>
<p>基本的UI界面设置完成后，接下来就是建立UI元素与代码的关联。<br>1.右上角两个圈圈（assitant editor）的按钮，将代码与UI同时显示，便于操作<br>2.将UI中得label与代码中得label像关联，只需要按住ctrl并拖动到代码中，设置合适的变量名称，类型，连接类型，存储类型等，对应代码左边会出现黑色的小圆圈来标记,并会自动在代码中创建一个label指针<br>3.按钮也类似，并指明相关的其他参数，比如触发事件等,只不过其连接方式是“Action”表示这是一个方法</p>
<blockquote>
<p>Tip:按alt移动鼠标到不同位置，再单击可快速看变量的信息</p>
<p>Tip:按ctrl并拖动不同的空间，即可以设置其边界属性，也可以与代码进行关联</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">UIKit</span></span><br><span class="line">//class definition, inherits <span class="keyword">from</span> <span class="type">UIViewController</span></span><br><span class="line">class <span class="type">ViewController</span>: <span class="type">UIViewController</span>  //single inheritance,单继承</span><br><span class="line">&#123;</span><br><span class="line">    //instance variables(property) &amp; methods，类中定义实例变量与实例方法</span><br><span class="line">    //define a property</span><br><span class="line">    //<span class="type">UILabel</span>!--optional</span><br><span class="line">    //@<span class="type">IBOutlet</span>--对应instance variable</span><br><span class="line">    //<span class="keyword">var</span> name: <span class="keyword">type</span>,变量的声明格式</span><br><span class="line">    //weak--storage <span class="keyword">type</span>, 对象总存在于heap中， 因此总是用指针来访问， 所以声明变量时不需要加”&amp;“之类的操作符来表示是指针。 //系统自动管理内存，但不是garbage collection，而是reference counting（<span class="type">ARC</span>）</span><br><span class="line">    @<span class="type">IBOutlet</span> weak <span class="keyword">var</span> display: <span class="type">UILabel</span>!</span><br><span class="line"></span><br><span class="line">    //<span class="keyword">when</span> input number, ignore the initialized <span class="string">"0"</span></span><br><span class="line">    //两种初始化方法：initializer，直接赋值</span><br><span class="line">    <span class="keyword">var</span> userIsInTheMiddleOfTypingNumber: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    //define a <span class="keyword">method</span></span><br><span class="line">    //all number buttons are connected to this <span class="keyword">method</span></span><br><span class="line">    //@<span class="type">IBAction</span>--instance <span class="keyword">method</span></span><br><span class="line">    @<span class="type">IBAction</span> func appendDigit(sender: <span class="type">UIButton</span>) &#123; //non <span class="keyword">return</span> value</span><br><span class="line">    //@<span class="type">IBAction</span> func appendDigit(sender: <span class="type">UIButton</span>) --&gt; <span class="type">Double</span> &#123; //<span class="keyword">return</span> double</span><br><span class="line">        //decide which button act <span class="keyword">as</span> the sender</span><br><span class="line">        //<span class="keyword">let</span>--constant variable</span><br><span class="line">        //use dot to access a variable <span class="keyword">or</span> call a <span class="keyword">method</span></span><br><span class="line">        //digit没有声明特定的类型，但是swift是强类型语言，会自动推导类型'ype-inference'.</span><br><span class="line">        //这里查看digit的类型是显示“<span class="type">string</span>?”，问号表示optional（optional--<span class="keyword">not</span> <span class="type">set</span>(<span class="keyword">nil</span>,一种特殊的类型), 被推导的类型<span class="type">string</span>）,<span class="string">"!"</span>就是用来解包，获取正确的类型<span class="type">string</span></span><br><span class="line">        //假设把数字按钮“<span class="number">2</span>”设置的数字去掉，这里获取的值就是<span class="keyword">nil</span>，程序运行时按这个按钮就会导致程序崩溃</span><br><span class="line">        //因此这个“!”在调试阶段非常有用，如果有未设置的，很快就能发现bug，如果查看某个方法时，只要提示有“xxx?”，最后结果就应该加上“!”</span><br><span class="line">        <span class="keyword">let</span> digit = sender.currentTitle!</span><br><span class="line"></span><br><span class="line">        //<span class="string">"\()"</span> easily print values <span class="keyword">in</span> println</span><br><span class="line">        println(<span class="string">"digit=\(digit)"</span>)</span><br><span class="line">        <span class="keyword">if</span> userIsInTheMiddleOfTypingNumber &#123;</span><br><span class="line">            display.text = display.text! + digit</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            display.text = digit</span><br><span class="line">            userIsInTheMiddleOfTypingNumber = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于optional类型的理解—todo</p>
<ul>
<li><a href="http://blog.csdn.net/jasonblog/article/details/28876823" target="_blank" rel="external">随手记Swift基础和OptionalType（问号?和感叹号!）</a></li>
<li><a href="http://blog.csdn.net/woaifen3344/article/details/30244201" target="_blank" rel="external">Swift 学习之二十一：？和 ！（详解）</a></li>
</ul>
<h2 id="Lecture2-_More_Xcode_and_Swift,_MVC">Lecture2. More Xcode and Swift, MVC</h2><p>implicitly unwrapped optional<br>语法糖</p>
<h2 id="[第3集]_应用MVC">[第3集] 应用MVC</h2><h2 id="[第4集]_Swift语言与Foundation框架">[第4集] Swift语言与Foundation框架</h2><h2 id="[第5集]_Objective-C_兼容性、Property_List和Views">[第5集] Objective-C 兼容性、Property List和Views</h2><h2 id="[第6集]_协议、代理和手势">[第6集] 协议、代理和手势</h2><h2 id="[第7集]_多重_MVC">[第7集] 多重 MVC</h2><h2 id="[第8集]_View_Controller_Lifecycle,_Autola">[第8集] View Controller Lifecycle, Autola</h2><h2 id="[第9集]_Scroll_View_and_Multithreading">[第9集] Scroll View and Multithreading</h2><h2 id="[第10集]_Table_View">[第10集] Table View</h2><h2 id="[第11集]_Unwind_Segues,_Alerts,_Timers,_View_Animation">[第11集] Unwind Segues, Alerts, Timers, View Animation</h2><h2 id="[第12集]_Dynamic_Animation">[第12集] Dynamic Animation</h2><h2 id="playground使用">playground使用</h2><p>Q:新建一个playground项目时提示“no such module called cocoa/uikit”<br>A:platform不匹配，创建的时候选择的时候是OSX，但是打开file inspector可以看到其platform可能是iOS，修改为相应的platform就可<br><a href="http://blog.csdn.net/xunyn/article/details/38518961" target="_blank" rel="external">Swift初窥—Playground</a></p>
<hr>
<ul>
<li><a href="http://open.163.com/special/opencourse/ios7.html" target="_blank" rel="external">网易公开课：斯坦福大学公开课—iOS8应用开发</a></li>
<li><a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift" target="_blank" rel="external">github相关链接</a></li>
<li><a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099" target="_blank" rel="external">itunes官网视频链接</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[根据“斯坦福大学公开课-iOS8开发”课程记录一下课程要点与自己的想法，具体的东西可以参考文档或视频来进行理解，本文档不是通用性的iOS教程。]]>
    
    </summary>
    
      <category term="OC" scheme="http://shawnelee88.github.io/tags/OC/"/>
    
      <category term="Swift" scheme="http://shawnelee88.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/tags/iOS/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://shawnelee88.github.io/2015/07/16/hello-world/"/>
    <id>http://shawnelee88.github.io/2015/07/16/hello-world/</id>
    <published>2015-07-16T12:50:27.000Z</published>
    <updated>2015-07-09T13:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[proxychains+shadowsocks神器]]></title>
    <link href="http://shawnelee88.github.io/2015/07/10/proxychains-shadowsocks%E7%A5%9E%E5%99%A8/"/>
    <id>http://shawnelee88.github.io/2015/07/10/proxychains-shadowsocks神器/</id>
    <published>2015-07-10T15:14:11.000Z</published>
    <updated>2015-07-10T15:35:57.000Z</updated>
    <content type="html"><![CDATA[<p>安装了shadowsocks之后，只能网页出去逛逛，如果需要在command line中也能有同样的效果（ping不同，但是可以下载），需要配合proxychains4这个神器</p>
<h2 id="安装">安装</h2><p>1.mac shadows安装简单</p>
<p>2.proxychains</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="keyword">cd</span> proxychains-ng</span><br><span class="line">./configure</span><br><span class="line">(sudo) <span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br><span class="line"><span class="keyword">cp</span> ./src/proxychains.<span class="keyword">conf</span> /etc/proxychians.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cd</span> .. &amp;&amp; rm -rf proxychains-ng</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">brew install proxychains-ng  //mac</span><br></pre></td></tr></table></figure>
<h2 id="修改配置">修改配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vim</span> /etc/proxychains.conf</span><br><span class="line">推荐配置</span><br><span class="line">strict_chain</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet <span class="number">224</span></span><br><span class="line">tcp_read_time_out <span class="number">15000</span></span><br><span class="line">tcp_connect_time_out <span class="number">8000</span></span><br><span class="line">localnet <span class="number">127.0.0.0</span>/<span class="number">255.0.0.0</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  <span class="number">127.0.0.1</span> <span class="number">1080</span></span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl https:<span class="comment">//www.twitter.com/</span></span><br><span class="line">proxychains4 git <span class="keyword">push</span> origin master</span><br></pre></td></tr></table></figure>
<h2 id="测试proxychains4">测试proxychains4</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="keyword">https</span>://www.dropbox.com -v -O /dev/<span class="constant">null</span>   <span class="comment"> //直接输入这条语句连接不了</span></span><br><span class="line">proxychains4 wget <span class="keyword">https</span>://www.dropbox.com -v -O /dev/<span class="constant">null</span>  <span class="comment"> //加入proxychains4之后就可以顺利执行</span></span><br></pre></td></tr></table></figure>
<p>参考来源：</p>
<ul>
<li><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks官网—github</a></li>
<li><a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">proxychains4神器官网—github</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks/wiki/Using-Shadowsocks-with-Command-Line-Tools" target="_blank" rel="external">shadowsocks 官网wiki—配置proxychains</a></li>
<li><a href="http://blog.ainhaato.moe/proxychains-socks5-shell/" target="_blank" rel="external">利用proxychains在终端使用socks5代理</a></li>
<li><a href="http://blog.ihipop.info/2011/01/1988.html" target="_blank" rel="external">在终端下间接使用Socks5代理的几种方法(privoxy,tsocks,proxychains)—比较老，可以参考</a></li>
<li><a href="http://wsgzao.github.io/post/fq/" target="_blank" rel="external">gfw小结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[shadowsocks+proxychains神器，一枝红杏出墙来]]>
    
    </summary>
    
      <category term="proxychains" scheme="http://shawnelee88.github.io/tags/proxychains/"/>
    
      <category term="shadowsocks" scheme="http://shawnelee88.github.io/tags/shadowsocks/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC杂记]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/mac%E6%9D%82%E8%AE%B0/"/>
    <id>http://shawnelee88.github.io/2015/07/09/mac杂记/</id>
    <published>2015-07-09T14:35:41.000Z</published>
    <updated>2015-07-19T01:48:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="技巧">技巧</h3><h4 id="显示隐藏文件：">显示隐藏文件：</h4><p>显示：<code>defaults write com.apple.finder AppleShowAllFiles -bool true</code></p>
<p>隐藏：<code>defaults write com.apple.finder AppleShowAllFiles -bool false</code></p>
<p>隐藏某个文件夹：<br><code>chflags hidden /Users/lee/Downloads/未命名文件夹</code></p>
<p>取消隐藏某个文件夹<br><code>chflags nohidden /Users/lee/Downloads/未命名文件夹</code></p>
<h4 id="objdump—otool">objdump—otool</h4><p>objdump是linux下的工具，而mac提供的是<a href="http://blog.csdn.net/x32sky/article/details/45099979" target="_blank" rel="external">otool</a>，<br><code>objdump -Sl 类似于 otool -tv</code></p>
<p><a href="https://support.apple.com/zh-cn/HT204048" target="_blank" rel="external">mac安装windows(怎么卸载，怎么安装多个，todo)</a></p>
<h4 id="DigitalOcean相关：">DigitalOcean相关：</h4><p>官网3部曲：</p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-connect-to-your-droplet-with-ssh" target="_blank" rel="external">How To Connect To Your Droplet with SSH</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="external">Initial Server Setup with Ubuntu 14.04</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/additional-recommended-steps-for-new-ubuntu-14-04-servers" target="_blank" rel="external">Additional Recommended Steps for New Ubuntu 14.04 Servers</a></p>
<h4 id="如何比较好的卸载nodejs相关">如何比较好的卸载nodejs相关</h4><p>使用相关shell脚本即可<a href="[uninstallNodejs.sh--github](https://github.com/jesseyu/uninstallNodejs/blob/master/uninstallNodejs.sh)">^node</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">lsbom <span class="operator">-f</span> <span class="operator">-l</span> <span class="operator">-s</span> -pf /var/db/receipts/org.nodejs.pkg.bom \</span><br><span class="line">| <span class="keyword">while</span> <span class="built_in">read</span> i; <span class="keyword">do</span></span><br><span class="line">  sudo rm /usr/<span class="built_in">local</span>/<span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node \</span><br><span class="line">     /usr/<span class="built_in">local</span>/lib/node_modules \</span><br><span class="line">     /var/db/receipts/org.nodejs.*</span><br></pre></td></tr></table></figure>
<h3 id="软件">软件</h3><p><a href="http://synergy-project.org/?utm_referrer=http%3A%2F%2Fsynergy-project.org%2Fdownload%2F&amp;utm_expid=35973112-5.LQhO_zr3R7mw69eKHqIeWg.0" target="_blank" rel="external">多屏幕局域网内鼠标键盘共享软件synergy</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Mac OSX的一些记录]]>
    
    </summary>
    
      <category term="mac" scheme="http://shawnelee88.github.io/tags/mac/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/tags/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
      <category term="mac" scheme="http://shawnelee88.github.io/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OC学习笔记]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/OC%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shawnelee88.github.io/2015/07/09/OC编程学习/</id>
    <published>2015-07-09T14:35:41.000Z</published>
    <updated>2015-08-09T03:20:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>oc以c语言为基础，加入了对面向对象编程（OOP）的支持。</p>
<p>工具：xcode6</p>
<p>书籍：《Objective-C编程》—Aaron Hillegass[美]</p>
<h2 id="变量与类型">变量与类型</h2><h3 id="变量使用前必须声明，理由有2：">变量使用前必须声明，理由有2：</h3><ul>
<li>有了类型信息，编译器可以检测潜在的错误，比如将对字符串进行数学运算</li>
<li>根据类型分配存储空间</li>
</ul>
<h3 id="常用类型：">常用类型：</h3><p>c语言5种常用类型：</p>
<ul>
<li>整型: int, short, long</li>
<li>浮点: float, double</li>
<li>字符: char</li>
<li>指针: int *</li>
<li>结构体: struct</li>
</ul>
<h3 id="id">id</h3><p><code>id</code>：声明指针时并不知道所指对象的准确类型。为此，可以使用id类型。id的含义是：指针，并可以指向任意类型的Objective-C对象.<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="keyword">delegate</span>; <span class="comment">//不需要使用星号，本身就有星号的作用</span></span><br></pre></td></tr></table></figure></p>
<h3 id="局部变量，全局变量，静态变量">局部变量，全局变量，静态变量</h3><p>局部变量：函数运行时才会存在，调用函数时自动分配，函数结束后自动释放，也称<code>自动变量</code><br>全局变量：函数外声明，到处可以访问，其他文件如需访问，用extern<br>静态变量：只有在该文件内可以访问</p>
<hr>
<h2 id="oc与框架（framework）">oc与框架（framework）</h2><p>框架：有很多类组成的库<br>类：负责描述某个特定类型的对象，包括实例方法（instance method）和实例变量（instance variable）<br>实例：通过某个类创建的对象</p>
<h3 id="消息机制">消息机制</h3><h4 id="消息发送">消息发送</h4><p>消息发送必须写在一堆方括号中，并且必须包含以下两部分：<br>1.指针，指向接受消息的对象—接收方<br>2.方法名，要触发的方法的方法名—选择器<br>3.可以传入参数—参数<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[now dateByAddingTimeInterval:10000]</span>;</span><br><span class="line"><span class="attribute">now</span>:接收方</span><br><span class="line"><span class="attribute">dateByAddingTimeInterval</span>:选择器</span><br><span class="line"><span class="number">10000</span>:参数</span><br></pre></td></tr></table></figure></p>
<p>要调用方法，就需要向对象发送对应的消息，此为与c语言不同的地方。</p>
<h4 id="消息嵌套发送">消息嵌套发送</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSDate alloc] init]</span><br></pre></td></tr></table></figure>
<p>系统会先向NSDate类发送alloc消息，得到返回值（指向新建的NSDate实例的指针），再向这个指针发送init消息，再返回该对象的指针，alloc负责分配内存，init负责初始化里面的数据</p>
<h4 id="消息可以不带参数，也可以带多个参数">消息可以不带参数，也可以带多个参数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSDate</span> alloc]</span><br><span class="line"><span class="built_in">NSCalendar</span> *cal = [<span class="built_in">NSCalendar</span> currnetCalendar];</span><br><span class="line"><span class="built_in">NSUinteger</span> day = [cal ordinalityOfUnit:<span class="built_in">NSDayCalendarUnit</span> inUnit:<span class="built_in">NSMonthCalendarUnit</span> forDate:now];  </span><br><span class="line"><span class="comment">//方法为ordinalityOfUnit:inUnit:forDate:, 传入3个参数,用来计算某个某个日期是响应月份中的第几日</span></span><br></pre></td></tr></table></figure>
<h4 id="方法也可以分为类方法以及对象方法">方法也可以分为类方法以及对象方法</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[NSDate alloc]</span> <span class="comment">//对类NSDate发送alloc消息</span></span><br><span class="line"><span class="attr_selector">[NSDate alloc]</span> <span class="tag">init</span>]  <span class="comment">//alloc返回的结果是某个实例的指针，对该指针发送init消息</span></span><br></pre></td></tr></table></figure>
<h4 id="向nil发送消息">向nil发送消息</h4><p>大多数语言中，不允许向nil发送消息，oc则不同，允许向nil发送消息，什么事情都不会发生。<br>note1：如果程序向某个对象发送了消息，但是没有得到预期的结果，需检查消息接收方是否为nil<br>note2：向nil发送消息，得到的返回值没有意义</p>
<h4 id="@的几种含义">@的几种含义</h4><p>1.用在NSLog中<br>2.<code>%@</code>可以表示指向任何对象，会向对象发送<code>description</code>方法 eg:NSLog(@”%@…”)</p>
<h3 id="NSArray">NSArray</h3><h4 id="两种枚举方法">两种枚举方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *dateList = [<span class="built_in">NSArray</span> arrayWithObjects:date1, date2, date3];</span><br><span class="line"><span class="built_in">NSUInteger</span> count = [dateList count];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;[dateList objectAtIndex:i];&#125;  <span class="comment">//普通枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSDate</span> *d <span class="keyword">in</span> dateList)&#123;&#125;    <span class="comment">//快速枚举，不应在枚举过程中增加或删除数组中的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="两种类型的数组">两种类型的数组</h4><p>1.NSArray,创建后不能增加或删除元素<br>2.NSMutableArray：可以增加或删除元素，是NSArray的子类<br>其他类也会有类似的两种不同类型，NSSet, NSMutableSet； NSDictionary,NSMutableDictionary</p>
<hr>
<h2 id="自定义类">自定义类</h2><h3 id="存取方法">存取方法</h3><p>3种存取方法<br>1.函数实现存取方法<br>2.点号存取<br>3.属性 property, synthesize</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface <span class="keyword">Person</span> : NSObject</span><br><span class="line">&#123;</span><br><span class="line">float heightInMeters;</span><br><span class="line">int weightInKilos;</span><br><span class="line">&#125;</span><br><span class="line">// 通过以下方法，可以存取相应的实例变量</span><br><span class="line">- (float)heightInMeters;</span><br><span class="line">- (void)setHeightInMeters:(float)height;</span><br><span class="line">- (int)weightInKilos;</span><br><span class="line">- (void)setWeightInKilos:(int)weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[]</span><span class="comment">[Person alloc]</span> init];</span><br><span class="line"><span class="comment">[person setWeightInKilos:96]</span>;  //函数实现存取方法</span><br><span class="line"><span class="comment">[person setHeightInMeters:1.8]</span>;</span><br><span class="line">int w = <span class="comment">[person weightInKilos]</span>;</span><br><span class="line">int h = <span class="comment">[person heightInMeters]</span>;</span><br><span class="line"><span class="keyword">person</span>.weightInKilos = 96;  //点号存取方法</span><br><span class="line"><span class="keyword">person</span>.heightInMeters = 1.8;</span><br><span class="line">int w1 = <span class="keyword">person</span>.weightInKilos;</span><br><span class="line">int h1 = <span class="keyword">person</span>.heightInMeters;</span><br><span class="line">//头文件中用@property属性</span><br><span class="line">@property float heightInMeters</span><br><span class="line">@property int weightInKilos;</span><br><span class="line">//实现文件中用@synthesize属性,会自动合成存取方法</span><br><span class="line">@synthesize heightInMeters, weightInKilos;</span><br></pre></td></tr></table></figure>
<h3 id="self">self</h3><p>类似于c++的this指针，指向运行当前方法的对象的指针，当需要向自己发送消息时，就需要使用self。</p>
<hr>
<h2 id="继承">继承</h2><p>ios sdk中得类都继承自NSObject（直接或间接地），他虽然拥有很多方法，但是只有1个实例变量：<code>isa指针</code>，任何对象的isa指针都会指向创建该对象的类，可以理解为“is-a”</p>
<blockquote>
<p>任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。—<a href="http://blog.csdn.net/wishfly/article/details/7384708" target="_blank" rel="external">Objective-C内存布局—描述isa指针</a>)</p>
</blockquote>
<p>消息的响应过程—继承链往上依次查找：</p>
<p>假设程序向某个对象发送了一个fido消息。收到消息的对象为了能响应这个消息，会通过isa指针找到该对象的类并查询“是否有名为fido的实例方法？”如果这个类拥有名为fido的方法，就会执行之。如果没有，就会向该类的父类查询象会沿着继承链向上查询，直到找到名为fido的方法，或者到达继承链的顶端为止。如果一直没有找到fido方法，并且位于继承链顶端的NSObject也回答“没有实现fido方法”时，程序就会报错</p>
<h3 id="super">super</h3><p>运行指定的方法，但是从对象的父类开始查找与之匹配的实现。与self相对应。</p>
<hr>
<h2 id="对象实例变量">对象实例变量</h2><p>指向另一个对象的指针，可用于描述相应两个对象之间的关系</p>
<p>三种常见用途：<br>对象属性—指针，指向某个单一的、代表某个值的对象，比如NSString,NSNumber对象<br>一对一关系—指针，指向单个复杂的对象。比如Employee中有一个指向Person实例的指针。<br>一对多关系—指针，指向某个collection类的实例，比如Person中又一个指向NSMutableArray的指针，该array中包含多个child</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Employee:<span class="keyword">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	int employeeID;</span><br><span class="line">	NSString *lastName;//对象属性</span><br><span class="line">	<span class="keyword">Person</span> *spouse;//一对一的关系</span><br><span class="line">	NSMutableArray *children;//一对多的关系</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>注意，对象只会保存其他对象的指针，而不是保存其他对象，可能会导致两个问题：<br>1.某个对象可能有多个角色，比如，其spouse还可能是多个child的紧急联系人<br>2.会导致产生大量独立的对象，耗尽可用内存，因此需要保留正在使用的对象，并释放那些不用的对象（内存回收）</p>
<h3 id="对象所有权与ARC（Automatic_Reference_Count,自动引用计数）">对象所有权与ARC（Automatic Reference Count,自动引用计数）</h3><p>MRC(手动引用计数，Manual Reference Count),与ARC相对应<br>当某个对象的拥有方个数为0，可以判定程序不在需要该对象，从而释放该对象。（“拥有方”可以理解为“被其他人拥有”，有其他对象内的指针指向该对象，如果拥有方个数为0，就表示不被任何人拥有，而自己拥有别人就无所谓）<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01L1tXDQUAo/yS30wEQ1Ovrm9k.jpg" alt="image"><br>上图中描述了简单的单向拥有关系，有以下几个：<br>1.最左边的NSMutableArray拥有多个Employee<br>2.每个Employee拥有多个Asset<br>3.每个Asset拥有一个NSString</p>
<p>对于这种情形，如果释放了NSMutableArray,则后续的所有对象都会被释放<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01zKSU37mYS/j9qVNJqlKV0A13.jpg" alt="image"><br>上图中描述了较复杂的双向拥有关系，除了上面提到的3点，还有1点：<br>1.每个Asset对象拥有各自的Employee，指向其对应的Employee对象</p>
<p>对于这种情形，如果释放了NSMutableArray,凡是拥有Asset对象的Employee对象都没有释放，因为虽然Employee对Asset的拥有关系消失了，但是Asset还对对应的Employee对象存在拥有关系，只有拥有方不为0，就不会自动释放。这就叫<code>retain循环</code>，是造成内存泄露的常见原因。</p>
<p>为了保证两个对象有一一对应的双向拥有关系，需要注意建立这种关系的时机（假设一个为父对象，一个为子对象）(—OC编程(2nd),chap20,避免内存泄露)</p>
<p>1.显式地设置这两个双向的关系,分别单独调用其设置关系的方法<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[father <span class="function"><span class="keyword">method</span>:</span>child]</span><br><span class="line">[child <span class="function"><span class="keyword">method</span>:</span>father]</span><br></pre></td></tr></table></figure></p>
<p>2.在为子对象设置指向父对象的指针时，同时设置父对象对子对象的拥有关系<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//child <span class="keyword">method</span></span><br><span class="line">-(<span class="type">void</span>) <span class="keyword">method</span>:(<span class="type">Fathertype</span> father)</span><br><span class="line">&#123;</span><br><span class="line">	holder = father;//为子对象设置指向父对象的指针</span><br><span class="line">	[father <span class="keyword">method</span>:self];//设置父对象对子对象的拥有关系，调用父对象的对应方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在为父对象设置对子对象的拥有关系时，同时设置子对象对父对象的拥有关系<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//father <span class="keyword">method</span></span><br><span class="line">-(<span class="type">void</span>)<span class="keyword">method</span>:(<span class="type">ChildType</span> c)</span><br><span class="line">&#123;</span><br><span class="line">	child = c;//为父对象设置对子对象的拥有关系</span><br><span class="line">	[c <span class="keyword">method</span>:self];//设置子对象对父对象的拥有关系,调用子对象的对应方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="如何分析内存泄露问题">如何分析内存泄露问题</h3><p>性能分析（profile） &amp; 性能分析工具（Instruments)—todo</p>
<h3 id="如何解决retain循环问题">如何解决retain循环问题</h3><h4 id="weak修饰符_与_strong修饰符">weak修饰符 与 strong修饰符</h4><p><code>strong</code> : 对于这个指针指向的对象，需要主张所有权，即必须要有人指向他，拥有它。<code>如下面的例子，就表示Asset对象对NSString对象有拥有权。**</code>当没有人拥有它时，这个label指向的NSString对象就可以释放。释放时，会收到dealloc信息（从NSObject继承），可以覆盖此dealloc方法。</p>
<p><code>__weak</code>:通过弱引用，可以解决<code>retain循环</code>问题。弱引用不主张所有权,如下面的例子，就表示Asset对象对holder没有拥有权,也就是说我们的Asset对象不会对其Employee对象存在拥有权，因此删除Employee对象的时候，所有对象都可以安全释放。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Employee</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Asset</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSString</span> *label;</span><br><span class="line">__<span class="keyword">weak</span> Employee *holder;  <span class="comment">//__weak修饰符，不主张所有权，也就是说Asset不会对它所对应的Employee对象存在拥有权</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> resaleValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *label; <span class="comment">//strong修饰符，必须主张所有权,也就是说这个Asset对象对NSString对象存在拥有权</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>) Employee *holder; <span class="keyword">@property</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> resaleValue; <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果对象间是父子关系，那么为了避免retain循环，通常需要遵守规则：父对象拥有子对象，但是子对象不能拥有父对象</p>
</blockquote>
<h4 id="弱引用的自动清零特性">弱引用的自动清零特性</h4><p>为什么可以解决“retain循环”问题？<br>当某个由弱引用指向的对象被释放时，相应的指针变量会被归零，即赋为nil。</p>
<h4 id="MRC(手动引用计数)">MRC(手动引用计数)</h4><p>参考C++中得智能指针，同时参考<a href="(http://www.pchou.info/ios/2015/06/05/oc-memory-management.html">网页资料</a>)来理解reference count<br>可以理解为一个对象本身有一个引用计数的成员变量。当创建一个对象时，用一个指针指向这个对象。<br>oc中，如果新建一个对象并赋值，则这个对象初始化为1，只有retain,release操作可以改变引用计数的值。<br>如果调用retai，则会+1，<br>如果调用release，则会-1，<br>如果最后为0，则会自动释放该内存</p>
<p>下面解释书中例子<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动管理引用计数</span></span><br><span class="line"><span class="comment">//假设这里newEmp指向了一个Employee对象，这里需要设置holder也指向他</span></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">setHolder:</span>(Employee *)newEmp</span><br><span class="line">&#123;</span><br><span class="line">	[holder release]; <span class="comment">//原来holder可能有指向一个对象，这里需要先解除这个指向关系，也就是原来被指向的对象的拥有者先减少，也就是原来的对象的引用计数减少</span></span><br><span class="line">	[newEmp retain];  <span class="comment">//因为holder需要指向新的对象，也就是newEmp指向的对象，因此这个对象多了一个拥有者，因此引用不过计数需要增加</span></span><br><span class="line">	holder = newEmp; <span class="comment">//将holder指向新的一个Employee对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">	[label release];   <span class="comment">//需要解除label的引用计数，以便自动释放内存  </span></span><br><span class="line">	[holder release];  <span class="comment">//需要解除holder对应关系，因此指向对象的引用计数需要-1</span></span><br><span class="line">	[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://d.pcs.baidu.com/thumbnail/ba68bf5c4481babf34fba692d8ff93a9?fid=604950169-250528-435242864476861&amp;time=1437066000&amp;rt=pr&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-%2bHiwaKhovsC%2fTXFDHBMyUglqfPw%3d&amp;expires=8h&amp;prisign=unknow&amp;chkbd=0&amp;chkv=0&amp;size=c10000_u10000&amp;quality=90" alt="image"></p>
<h4 id="autorelease—todo">autorelease—todo</h4><p>会在将来的某个时候收到release消息<br>什么时候收到release消息？当autorelease池（对象）被排干（drain）的时候</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">NSString</span> *)description &#123;</span><br><span class="line">	<span class="type">NSString</span> *<span class="literal">result</span> = [[<span class="type">NSString</span> alloc] initWithFormat:@<span class="string">"&lt;%@: $%d &gt;"</span>,                                             [self label], [self resaleValue]];</span><br><span class="line">	[<span class="literal">result</span> autorelease];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建autorelease池（对象）</span><br><span class="line"><span class="type">NSAutoreleasePool</span> *arp = [[<span class="type">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="type">Asset</span> *asset = [[<span class="type">Asset</span> alloc] init];</span><br><span class="line"><span class="type">NSString</span> *d = [asset description]; // d指针指向的<span class="type">NSString</span>对象已经在autorelease池中</span><br><span class="line">[arp drain]; // description方法所返回的<span class="type">NSString</span>对象会收到release消息</span><br></pre></td></tr></table></figure>
<p>虽然ARC会自动使用autorelease池，但是必须由程序创建并排空相应的autorelease池，如果开启了ARC极致，也加入了创建autorelease池的语法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建autorelease池（对象）</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	Asset *asset = [[Asset alloc] init];</span><br><span class="line">	<span class="built_in">NSString</span> *d = [asset description];     <span class="comment">// d指针指向的NSString对象已经在autorelease池中</span></span><br><span class="line">&#125; <span class="comment">// autorelease池已经被排空</span></span><br></pre></td></tr></table></figure>
<h4 id="retain计数规则">retain计数规则</h4><p>规则如下：（假设，“你”—“当前正在使用的某个类实例”）</p>
<ul>
<li>如果创建对象的方法名是alloc或new开头，或包含copy，则你已经得到了该对象的所有权（retain计数=1，而且该对象不在NSAutoReleasePool对象中）。你负责在不需要的时候释放。常见的会传输所有权的方法:alloc(跟一个init), copy, MutableCopy</li>
<li>其他途径创建的对象（便捷方法—todo？？？），你是没有所有权的（retain计数是1，而且在NSAutoReleasePool中，如果没有保留该对象，则当NSAutoReleasePool被drain时，对象自动释放）</li>
<li>如果不拥有某个对象，但是期望他继续存在，则可以发送retain消息来获取所有权</li>
<li>如果拥有某个对象并且不在需要使用时，可以发送release/autorelease消息。autorelease消息会导致：当NSAutoReleasePool被drain时，再向相应对象发送release消息</li>
<li>只要至少有一个拥有方，就会继续存在，当ratain计数=0，则会受到dealloc消息，自动释放</li>
</ul>
<blockquote>
<p>从局部的角度来看问题</p>
</blockquote>
<hr>
<h2 id="Collection类">Collection类</h2><h3 id="NSArray/NSMutableArray">NSArray/NSMutableArray</h3><h4 id="拥有权问题">拥有权问题</h4><p>将某个对象加入数组对象，则数组对象会成为该对象的拥有方；将某个对象移出数组对象，数组对象就会放弃该对象的所有权。init也叫初始化方法，类似于c++中得构造函数，构造函数可以因为参数不同有很多个，初始化方法也类似。</p>
<h4 id="可修改版本_vs-_不可修改版本">可修改版本 vs. 不可修改版本</h4><p>NSArray初始化：</p>
<ul>
<li>必须以nil结尾，一边知道数组个数</li>
<li>优点：<ul>
<li>保证数组内容“安全”，不可修改</li>
<li>性能考虑：不可修改对象永远无须拷贝。NSArray的copy方法仅返回指向自身的指针，而NSMutableArray的copy方法则会制作一份自己的拷贝，并返回指向新数组对象的指针</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *colors = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Orange"</span>, <span class="string">@"Yellow"</span>, <span class="string">@"Green"</span>, <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h4 id="排序">排序</h4><p>排序描述对象（sort descriptors）,每个对象有一个<code>key属性</code>和<code>ascending属性</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">NSMutableArray</span>方法</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">sortUsingDescriptors</span>:<span class="value">(NSArray *)sortDescriptors</span></span>;</span><br></pre></td></tr></table></figure>
<p>为何参数是一个数组？<br>比如对人名排序，先按姓氏排序，如果姓氏相同，按名称升序排列，如果都相同，可按zipcode排序<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01WkDsKkoF0/lzNVd33YaxR8IS.jpg?thumb=256x&amp;scale=auto" alt="image"></p>
<h4 id="过滤">过滤</h4><p>NSPredicate类，其对象可以包含一条语句，其运算结果可以为“真”或“假”,详细可以阅读扩展文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pUsing.html" target="_blank" rel="external">Predicate Programming Guide</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span>方法</span><br><span class="line">- (<span class="keyword">void</span>)filterUsingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line"><span class="built_in">NSArray</span>方法</span><br><span class="line">- (<span class="built_in">NSArray</span> *)filteredArrayUsingPredicxate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line"></span><br><span class="line">例子：创建predicate对象，并应用于allAssets数组对象，结果是返回满足predicate条件的所有数组元素，其条件就是对数组元素分别进行<span class="string">"holder.valueOfAssets &gt; 70"</span>这样的判断</span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"holder.valueOfAssets &gt; 70"</span>];         <span class="built_in">NSArray</span> *toBeReclaimed = [allAssets filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h3 id="NSSet/NSMutableSet">NSSet/NSMutableSet</h3><h4 id="概念">概念</h4><p>里面的对象<code>无序，唯一</code>，最大用处是检查某个对象是否存在<br>eg.员工可以有多个物品，但是某个物品只属于一个员工，因此可以用NSMutableSet带起NSMutableArray来管理assets<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01ENpE0PFLz/gC5OdYei6BOFt7.jpg" alt="image"></p>
<h4 id="访问">访问</h4><p>因为无序，所以不能以索引来访问，使用特殊的方法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">containsObject</span>:<span class="value">(id)x</span></span>;</span><br></pre></td></tr></table></figure>
<p>当收到这个消息时，会查找set对象中和x相等的对象。<br>“相等”—就是”isEqual:”方法<br>可以重写这个方法，定义自己的“相等”比较<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *x = ...;</span><br><span class="line"><span class="built_in">NSString</span> *y = ...;</span><br><span class="line">如果x和y的地址一样，则称“相同”</span><br><span class="line">如果x和y指向的对象完全一样，则称“相等”</span><br><span class="line">“相同”一定“相等”，而“相等”不一定“相同”</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObject:(<span class="keyword">id</span>)anObject;<span class="comment">//发送“isEqual:”消息，检查是否“相等”</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObjectIdenticalTo:(<span class="keyword">id</span>)anObject;<span class="comment">//用“==”运算符，检查是否“相同”</span></span><br></pre></td></tr></table></figure></p>
<h3 id="NSDictionary/NSMutableDictionary">NSDictionary/NSMutableDictionary</h3><h4 id="概念-1">概念</h4><p>以NSString对象为索引，是键值对的集合（key-value），也是无序的<br>分别以“CEO”，“CTO”为key建立Dictionary对象<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01xD3EqUIjp/N1RnV8V0gR8SLK.jpg" alt="image"></p>
<h3 id="collection类相关">collection类相关</h3><h4 id="C语言基本类型">C语言基本类型</h4><p>collection对象只能保存对象，如果需要保存float，int，指针等变量，需要先把这些c语言基本类型封装为对象，再存入collection对象。<br>NSNumber—保存数字类型<br>NSValue—保存指针和部分特定的结构类型</p>
<h4 id="nil">nil</h4><p>collection对象不能保存nil，如果确实需要加入，可以使用NSNull类，该类只有一个实例，代表空。NSArray初始化时再末尾加入nil，知识用来标记数组的结尾。</p>
<hr>
<h2 id="常量">常量</h2><p>定义常量两种方法：<code>#define,全局变量</code></p>
<h4 id="预处理指令：#include,_#import,_#define">预处理指令：<code>#include, #import, #define</code></h4><p><code>#import</code>:会确保预处理器值导入特定文件一次<br><code>#include</code>:允许多次导入同一个文件<br>为了简化文件导入并加快便以速度，引入<code>预编译文件xxx.pch</code></p>
<h4 id="全局变量">全局变量</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocale</span> *here = [<span class="built_in">NSLocale</span> currentLocale];</span><br><span class="line"><span class="built_in">NSString</span> *currency = [here objectForKey:<span class="string">@"currency"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Money is %@"</span>, currency);</span><br><span class="line"><span class="comment">//上面个方法输入@"currency"不是很好，可用全局变量来替换</span></span><br><span class="line"><span class="built_in">NSLocale</span><span class="variable">.h</span>中声明</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *<span class="built_in">NSLocaleCurrencyCode</span>;</span><br><span class="line"><span class="built_in">NSLocale</span><span class="variable">.m</span>中定义</span><br><span class="line"><span class="built_in">NSString</span> <span class="keyword">const</span> *<span class="built_in">NSLocaleCurrencyCode</span> = <span class="string">@"currency"</span>;</span><br><span class="line">可以方便的使用，而且不会有输错得情况发生，xcode会自动补全</span><br><span class="line"><span class="built_in">NSString</span> *currency = [here objectForKey:<span class="built_in">NSLocaleCurrencyCode</span>];</span><br></pre></td></tr></table></figure>
<h4 id="enum">enum</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">typedef</span> enum  &#123;</span><br><span class="line">	<span class="keyword">BlenderSpeedStir,</span><br><span class="line"></span>	<span class="keyword">BlenderSpeedChop,</span><br><span class="line"></span>	<span class="keyword">BlenderSpeedLiquify,</span><br><span class="line"></span>	<span class="keyword">BlenderSpeedPulse,</span><br><span class="line"></span>	<span class="keyword">BlenderSpeedIceCrush </span>&#125;</span><br><span class="line"><span class="keyword">BlenderSpeed;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义常量时，最好使用全局变量和enum，而不是#define</p>
</blockquote>
<h2 id="NSString和NSData，文件">NSString和NSData，文件</h2><h3 id="NSString对象与文件">NSString对象与文件</h3><p>需要注意字符串编码，UTF-8</p>
<h4 id="NSString—&gt;文件">NSString—&gt;文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path</span><br><span class="line">atomically:(<span class="built_in">BOOL</span>)useAuxiliaryFile</span><br><span class="line">encoding:(<span class="built_in">NSStringEncoding</span>)enc     <span class="comment">//指定字符串编码，NSUTF8StringEncoding</span></span><br><span class="line">error:(<span class="built_in">NSError</span> **)error  <span class="comment">//指针的指针，而且error对象一开是并没有被实例化，只有真正发生错误了才会创建error对象</span></span><br></pre></td></tr></table></figure>
<h4 id="文件—&gt;NSString">文件—&gt;NSString</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(instancetype)</span>initWithContentsOfFile:<span class="params">(<span class="variable">NSString</span> *)</span>path</span><br><span class="line">encoding:<span class="params">(<span class="variable">NSStringEncoding</span>)</span>enc</span><br><span class="line">error:<span class="params">(<span class="variable">NSError</span> **)</span>error</span></span><br></pre></td></tr></table></figure>
<h4 id="NSData—&gt;文件">NSData—&gt;文件</h4><p>NSData对象“代表”内存中某块缓冲区<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)writeToFile:(<span class="built_in">NSString</span> *)path</span><br><span class="line">options:(<span class="built_in">NSDataWritingOptions</span>)mask   <span class="comment">//可以指定操作原子性，NSDataWritingAtomic</span></span><br><span class="line">error:(<span class="built_in">NSError</span> **)errorPtr</span><br></pre></td></tr></table></figure></p>
<h4 id="文件—&gt;NSData">文件—&gt;NSData</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="params">(instancetype)</span>dataWithContentsOfFile:<span class="params">(NSString *)</span>path</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="回调">回调</h2><p>NSRunLoop类，对应的实例会持续等待，当特定事件发生时，就会触发回调，向相应的对象发送消息。<br>三种途径实现回调：</p>
<p>1.目标-动作（target-action）<br>：在制定的时刻触发事件，很多简单的用户界面控件（按钮，滑块）都采用“目标-动作”机制。“当x发生时，向指定的对象发送某个特定的消息”，接受消息的对象就是目标（target），而消息的选择器（selector）就是动作（action）<br>2.辅助对象（helper objects）<br>“当x发生时，向遵守相应协议的辅助对象发送消息”，<code>委托对象</code>（delegate）和<code>数据源</code>（data source）是常见的辅助对象<br>3.通告（Notification）<br>通告中心，在应用开始等待前，告知通告中心“某个对象正在等待某些特定的通告，当其中的通告出现时，向指定的对象发送特定的消息”。当x发生时，会向通告中心发布通告，然后由通告中心转发给正在等待该通告的对象。</p>
<p>回调规则：<br>1.当要向一个对象发送一个回调时，使用“目标-动作对”<br>2.当要向一个对象发送多个回调时，apple会使用符合相应协议的辅助对象（辅助对象（委托对象或者数据源）需要实现协议的部分或全部方法）<br>3.向多个对象发送回调时，使用“通告”</p>
<h3 id="目标-动作对">目标-动作对</h3><p>NSTimer对象使用的是目标-动作对机制。创建该对象时，要设定延迟、目标和动作。在指定的延迟时间后，该对象会向设定的目标发送指定的消息。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"><span class="annotation">@interface</span> <span class="string">Logger :</span> NSObject</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sayOuch:</span>(NSTimer *)t;</span><br><span class="line">- <span class="annotation">@end</span></span><br><span class="line"></span><br><span class="line">Logger *logger = [[Logger alloc] init];</span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">2.0</span></span><br><span class="line"><span class="string">target:</span>logger   <span class="comment">//target设为logger对象</span></span><br><span class="line"><span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">sayOuch:</span>)         <span class="comment">//action设置为logger的sayouch:方法</span></span><br><span class="line"><span class="string">userInfo:</span>nil</span><br><span class="line"><span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] run];   <span class="comment">//循环等待</span></span><br></pre></td></tr></table></figure>
<h4 id="selector选择器">selector选择器</h4><p>向某个对象发送消息时，会沿着继承层次结构向上，直到某个类回应“我有与消息名称相匹配哦的方法”<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01hxkO9U2HD/DfIK8kdjajgjRd.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<p>方法的查询必须非常快速。如果使用方法的实际名称（可能会很长）进行查询，那么查询速度会很慢。为了提速，编译器会为每个其接触过的方法附上一个唯一的数字。运行时，程序使用的是这个数字，而不是方法名，因此上面的代码中需要指定 <code>selector:@selector(sayOuch:)         //action设置为logger的sayouch:方法</code><br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01NmnARRJ9h/VoDvuSAAxak0EU.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<h3 id="辅助对象">辅助对象</h3><p>比如NSURLConnection例子，其方法<code>sendSynchronousRequest:returningResponse:er-ror:</code>可从web服务器获取数据，但是获取数据时会<code>阻塞</code>该主线程，而且某些情况下可能无法实现回调，比如当web服务器要求提供用户名以及密码的时候，因此以<code>异步</code>的模式来使用：先要求NSURLConnection对象获取数据，然后等待回调，当发生（1）得到数据（2）web服务器要求认证信息（3）数据获取失败 这几种情况时，会触发回调。</p>
<p>怎样设置这样的回调？？？<br>为NSURLConnection对象设置一个辅助对象。当特定的事件发生时，该NSURLConnection对象会向辅助对象发送相应的消息。</p>
<p>具体是哪些消息？？？<br>Apple为NSURLConnection提供了一套协议（protocol）。<code>协议</code>是一系列方法声明，辅助对象可以根据协议实现相应的方法。</p>
<p>因此我们新建的辅助对象作为NSURLConnection的delegate（委托对象），需要实现部分或全部协议规定的方法，并在方法中定义自己的行为，比如保存从web服务器取回的数据。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__unused NSURLConnection *fetchConn = [[NSURLConnection alloc] <span class="string">initWithRequest:</span>request</span><br><span class="line"><span class="string">delegate:</span>logger    <span class="comment">//设置delegate对象，，特定事件发生时，就会向辅助对象（delegate也就是logger对象）发送相应的消息（符合协议的一些方法），也就是让logger调用对应的消息，因此logger中需要按照协议实现部分或全部方法</span></span><br><span class="line"><span class="string">startImmediately:</span>YES];</span><br></pre></td></tr></table></figure>
<h3 id="通告中心">通告中心</h3><p>将多个对象通过通告中心将自己注册为观察者（observer），当发生某个事件时，会向通告中心发送通告，再由通告中心将该通告转发给相应的观察者（观察者模式），也就是说对应的观察者需要实现对应的方法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">addObserver</span><span class="pseudo">:logger</span>   <span class="comment">//将自己注册到观察中心，成为观察者</span></span><br><span class="line"><span class="tag">selector</span>:@<span class="tag">selector</span>(<span class="attribute">zoneChange</span>:)    <span class="comment">//收到通告之后会转而向观察者发送这个消息</span></span><br><span class="line"><span class="tag">name</span><span class="pseudo">:NSSystemTimeZoneDidChangeNotification</span>    <span class="comment">//收到的通告名称，也就是说收到这个通告之后，通告中心会向logger这个观察者发送zoneChange：的消息</span></span><br><span class="line"><span class="tag">object</span><span class="pseudo">:nil</span>];</span><br></pre></td></tr></table></figure>
<h3 id="回调与对象所有权">回调与对象所有权</h3><blockquote>
<p>无论哪种类型的回调，如果代码编写有问题，都有可能使等待回调的对象得不到正确的释放</p>
</blockquote>
<p>有一些规则需要遵守：(各自对象释放的时候取消这种关联，也就是只需要管好自己的就行，否则管理太乱)<br>1.通告中心不拥有其下的观察者，如果将某个对象注册为观察器，那么通常应该在释放该对象时，将其移出通告中心</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span>
{
    <span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">removeObserver</span><span class="pseudo">:self</span>];
}
</code></pre><p>2.对象不拥有其下的委托对象或数据源对象。如果某个新创建的对象是另一个对象的委托对象或数据源对象，那么该对象应该在其dealloc方法中取消相应的关联</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span>
{
    <span class="attr_selector">[windowThatBossesMeAround setDelegate:nil]</span>;
    <span class="attr_selector">[tableViewThatBegsForData setDataSource:nil]</span>;
}
</code></pre><p>3.对象不拥有其目标。如果某个新创建的对象是另一个对象的目标，那么该对象应该在其dealloc方法中将相应的目标指针赋为0</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">dealloc</span>
{
     <span class="attr_selector">[buttonThatKeepsSendingMeMessages setTarget:nil]</span>;
}
</code></pre><h3 id="协议">协议</h3><p>在“辅助对象“提到过协议。<br>eg，iOS进程用UITableView实例来显示数据，但是该对象本身并不包含要显示的数据，必须从其他对象获取，因此，必须告诉UITableView对象，谁是你要的对象，这个对象将扮演数据源的角色。</p>
<p>应该怎样指定某个对象，使之成为UITableView的数据源？使用协议（protocol）</p>
<p><code>协议</code>是一组方法声明，其中的部分方法是必需的（required），另一些则是可选的（optional）。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableView</span>的数据源协议是<span class="built_in">UITableViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDataSource</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// UITableView对象的数据源必须实现以下方法</span></span><br><span class="line"><span class="keyword">@required</span>    <span class="comment">//必须方法</span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">@optional</span>    <span class="comment">//可选方法</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时，只需要让对应的对象遵守这个协议就可以,这样TerrificViewController就可以作为UITableView的数据源</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TerrificViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是在Logger.h中，并没有将Logger声明为遵守相应的协议。这是因为直到作者编写本书时，Apple也没有为NSURLConnection的委托对象提供正式的协议。因此该例子中并没有继承一个协议，而是直接实现了自己的方法</p>
</blockquote>
<hr>
<h2 id="property_list格式，以及实战iOS应用">property list格式，以及实战iOS应用</h2><h3 id="property_list">property list</h3><p>为了处理数据的需要，有时需要使用某种特定格式的文件，既可以有计算机读取，也便于人识别：属性列表（property list,xxx.plist文件,XML格式）可以有以下对象组成—NSArray,NSDictionary,NSString,NSData,NSDate,NSNumber</p>
<h3 id="MVC">MVC</h3><p>MVC（Model-View-Controller,模型-视图-控制器）是一种设计模式</p>
<ul>
<li>model,负责保存数据，并能让其他对象访问这些数据。NSString,NSDate,NSArray等</li>
<li>view,应用中可见的元素，知道如何在屏幕上画出自己，并能响应用户输入。能够看得见的就是view对象，包括UIView,UITableView,UITextView,UIButton等</li>
<li>controller，负责执行程序的逻辑功能，以连接和驱动应用的不同组成部分，可以处理事件，并能与其他对象协同工作。model与view之间没有之间关联，需要controller从中协调，任务繁重但关键。controller会接受某些对象发出的消息，并转发相应指令给其他对象，类似于委托的工作。</li>
</ul>
<p><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01ueSBKJz9V/fhvSo3gu5QC9qd.jpg?thumb=384x&amp;scale=auto" alt="image"></p>
<h3 id="原理解释">原理解释</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.main函数作用<br>（1）UIApplicationMain会创建UIApplication类的实例（单实例）<br>（2）根据第四个参数，创建相应的类实例并设置为应用的委托对象，该对象会收到各种应用委托消息。</p>
<p>2.main函数流程如何转到委托对象中？<br>启动时UIApplication实例会向委托对象发送<code>application:didFinishLaunchingWithOptions:</code>消息，因此AppDelegate必须继承<code>UIApplicationDelegate</code>协议（代码自动生成，前面那个方法属于这个协议），且AppDelegate中必须实现这个方法。而且，凡是需要在程序能够和用户交互前就完成的初始化工作，都应在这个方法中实现。</p>
<hr>
<h2 id="iOS应用_vs-_Mac应用">iOS应用 vs. Mac应用</h2><p>Cocoa Touch框架例子的类关系图 vs. Cocoa框架例子的类关系图<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01hAGre7xlG/S4K0l7J2FozTdL.jpg" alt="image"><br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01voHPRj21Y/8XirvYbOmdfdYa.jpg" alt="image"></p>
<p>1.iOS—Cocoa Touch框架,使用UITableView, UITextField, UIButton…<br>Mac—Cocoa框架,使用NSTableView, NSTextField, NSButton…<br>2.手写代码 vs. Interface Builder —todo<br>3.Cocoa应用是基于文档的应用，可同时打开多个任务列表。<br>4.Cocoa Touch框架基于文档Document（继承NSDocument），没有应用委托对象，而Cocoa框架则又应用委托对象AppDelegate。基于文档的应用，用户可以同时打开多个文档对象，所以运行时可以有多个 Document实例，而每个实例都有自己的表格视图、按钮、任务数组和窗口等。<br>5.IBOutlet,IBAction,告诉Xcode，相应的指针或动作方法会通过Interface Builder而不是写代码来建立关联。设置之后就会成为插座变量，会再第8点中，在弹出菜单中显示以便选择今儿建立关联。实际上这两个关键字没有真正的含义。<br>6.NSTableView对象其实是嵌套对象，包含NSScrollView,NSTableView,NSTableColumn对象。如果需要选中某个特定的对象，<code>ctrl+shift+左键单击</code><br>7.怎样自动调整窗口大小<code>autosizing</code>和相对位置？Xcode6中默认看不到，需要将file inspector中得auto layout关闭<br>8.如何创建关联关系？<code>ctrl+鼠标拖动</code>,其实目的就是为一些指针赋值，比如为按钮设置target，action；或者为某个NSTableView设置对应的datasource<br>9.既然作为NSTableView的数据源，就需要实现其对应的协议的部分方法。比如修改条目时内容变化进而保存数据。<br>10.保存文档，载入文档的数据处理</p>
<hr>
<h2 id="OC高级主题">OC高级主题</h2><h3 id="init">init</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[NSMutableArray alloc]</span> init]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>aloc负责分配对象空间，init负责对象空间的初始化。init是实例方法，而alloc是类方法。</p>
<h4 id="推荐的init写法">推荐的init写法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="keyword">init</span> &#123;</span><br><span class="line">	<span class="comment">// 调用NSObject的init方法</span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">	<span class="comment">// 父类的init方法的返回值是否为非nil?</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="comment">//通过存取方法为voltage赋值</span></span><br><span class="line">		[<span class="keyword">self</span> segVoltage:<span class="number">120</span>];</span><br><span class="line">		<span class="comment">//直接赋值，两种方法都可以</span></span><br><span class="line">		voltage = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定初始化方法">指定初始化方法</h4><p><code>[[OwnedApplicnace Alloc] init];</code>初始化方法调用链<br><img src="http://image.webreader.duokan.com/mfsv2/download/s010/p01fOAX9ChTi/3M8r9fB0GFk0q5.jpg" alt="image"></p>
<p>编写初始化方法时，应该遵循以下规则：</p>
<ul>
<li>规则1：如果某个类有多个初始化方法，那么应该由其中的一个方法来完成实际的任务，该方法称为<code>指定初始化方法</code>。其他的初始化方法都应该（直接地或间接地）调用指定初始化方法。  </li>
<li>规则2：指定初始化方法应该先调用父类的指定初始化方法，然后再对实例变量进行初始化.</li>
<li>规则3：如果某个类的指定初始化方法和父类的不同（这里指的是方法名不同），就必须覆盖父类的指定初始化方法，并调用新的指定初始化方法。</li>
<li>规则4：如果某个类有多个初始化方法，就应该在相应的头文件中明确地注明，哪个方法是指定初始化方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Appliance类</span></span><br><span class="line"><span class="comment">//指定初始化方法，满足规则4</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn &#123;</span><br><span class="line">	<span class="comment">// 规则2，调用NSObject的init方法</span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">	<span class="comment">// 规则2，为productName赋值</span></span><br><span class="line">	[<span class="keyword">self</span> setProductName:pn];</span><br><span class="line">	<span class="comment">// 为voltage赋初始值</span></span><br><span class="line">	[<span class="keyword">self</span> setVoltage:<span class="number">120</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> initWithProductName:<span class="string">@"Unknown"</span>];</span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line"><span class="comment">//OwnedAppliance类</span></span><br><span class="line"><span class="comment">//指定初始化方法，规则4</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn</span><br><span class="line">firstOwnerName:(<span class="built_in">NSString</span> *)n &#123;</span><br><span class="line">	<span class="comment">//调用父类的初始化方法</span></span><br><span class="line">	<span class="keyword">self</span> = [<span class="keyword">super</span> initWithProductName:pn];</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">		<span class="comment">// 创建NSMutableSet实例，用于保存拥有者的姓名</span></span><br><span class="line">		ownerNames = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">		<span class="comment">// 传入的第一个拥有者姓名是否为nil？</span></span><br><span class="line">		<span class="keyword">if</span> (n) &#123;</span><br><span class="line">			[ownerNames addObject:n];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回指向新对象的指针</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)initWithProductName:(<span class="built_in">NSString</span> *)pn &#123;</span><br><span class="line">	<span class="comment">//规则3，调用新的指定初始化方法</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> initWithProductName:pn firstOwnerName:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line">[[OwnedAppliance alloc] init];</span><br><span class="line"><span class="comment">//Q：上面这个方法是否可以正确的初始化实例？是否需要实现init方法？</span></span><br><span class="line"><span class="comment">//A: 可以正确初始化，不需要覆盖实现init方法。因为没有实现init，因此上述调用会根据调用链找父类的init方法，而父类的init方法中的有`[self initWithProductName:@"Unknown"]`局域，其中self指向的时OwnedAppliance实例（多态），所以调用OwnedAppliance的`initWithProductName:`方法，今儿调用自己的指定初始化方法`initWithProductName:firstOwnerName:`;而指定初始化方法调用了super的指定初始化方法`initWithProductName:`，而父类的这个方法最后又调用了NSObject得init方法.</span></span><br></pre></td></tr></table></figure>
<h4 id="禁用init方法">禁用init方法</h4><p>上面的方法带有默认实参，比如Appliance的init方法付过不指定名称会以“Unknown”作为默认参数，但如果我们必须要求一个有效值时怎么处理比较好？覆盖父类的指定初始化方法，告知程序员不能使用这个方法，并提供修改建议(<code>抛出异常</code>—todo)。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (id)<span class="tag">init</span> &#123;</span><br><span class="line">	<span class="variable">@throw</span> [NSException <span class="attribute">exceptionWithName</span>:@<span class="string">"WallSafeInitialization"</span>                                    	<span class="attribute">reason</span>:@<span class="string">"Use initWithSecretCode:, not init"</span>                                  	<span class="attribute">userInfo</span>:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="属性">属性</h2><h3 id="属性的特性">属性的特性</h3><p>属性的特性可以控制如何创建存取方法<br>分类：<br>按存取类型：<br>rewrite(默认), readonly<br>按生命周期类型分(决定存方法如何处理与其相关的内存管理问题)：<br>unsafe_unretained：默认，而且非对象类型的实例变量应该使用这个特性  —针对非对象类型<br>strong：保留传入的对象，并放弃原有对象（如果原有对象不再有其他拥有方就会被释放），凡是指向对象类型的实例变量通常应该用此特性。   —针对对象类型<br>weak：不保留传入的对象，相应的存方法会将传入的对象直接赋给实例变量。如果该对象被释放，相应的实例变量会被自动赋为nil   —针对对象类型<br>copy：要求拷贝传入的对象，并将新对象赋给实例变量。—针对对象类型</p>
<h4 id="copy—todo">copy—todo</h4><p>[不可变对象 copy],返回相同不可变对象<br>[不可变对象 mutableCopy],返回新的可变对象<br>[可变对象 copy],返回新的不可变对象<br>[可变对象 mutalbeCopy],返回新的可变对象（<a href="http://my.oschina.net/aofe/blog/266677" target="_blank" rel="external">OC中copy得使用</a>）</p>
<h4 id="atomic/nonatomic">atomic/nonatomic</h4><p>适用于多线程编程范畴。一般属性默认为atomic，因此需要手动加上nonatomic</p>
<p><code>(readwrite, copy, nonatomic)</code></p>
<h3 id="KVC(key-value_coding)">KVC(key-value coding)</h3><p>KVC（key-value coding）能够让程序通过名称直接存取属性。因为与KVC有关的方法都是在NSObject中定义的，所以凡是继承自NSObject的类都具备KVC功能。<br><code>setValue:forKey:</code>方法,会查找名为<code>setProductName:</code>的存方法（set-Value:forKey:方法是在NSObject中定义的）.如果没有setProductName:方法，直接为实例变量赋值。</p>
<p><code>valueForKey:</code>方法,会查找名为<code>productName:</code>的取方法（valueForKey:方法是在NSObject中定义的）。如果对象没有productName:方法，就会直接返回相应的实例变量。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[a <span class="string">setProductName:</span>@<span class="string">"Washing Machine"</span>];</span><br><span class="line">[a <span class="string">setValue:</span>@<span class="string">"Washing Machine"</span> <span class="string">forKey:</span>@<span class="string">"productName"</span>];</span><br><span class="line">NSLog(@<span class="string">"the product name is %@"</span>, [a productName]);</span><br><span class="line">NSlog(@<span class="string">"the product name is %@"</span>, [a <span class="string">valueForKey:</span>@<span class="string">"productName"</span>]);</span><br><span class="line"><span class="comment">//对于非对象类型，需要先转化为对象类型，比如int--&gt;NSNumber</span></span><br><span class="line">[a <span class="string">setVoltage:</span><span class="number">240</span>];</span><br><span class="line">[a <span class="string">setValue:</span>[NSNumber <span class="string">numberWithInt:</span><span class="number">240</span>] <span class="string">forKey:</span>@<span class="string">"voltage"</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么需要KVC？<br>当Apple提供的框架需要向读者编写的对象写入数据时，会使用setValue:forKey:方法<br>当Apple提供的框架需要从读者编写的对象读取数据时，会使用valueForKey:方法<br>Core Data框架为例（Core Data框架能够将对象保存在SQLite数据库中，并在需要时将其还原成对象），这套框架会通过KVC来管理自定义的数据对象。</p>
</blockquote>
<hr>
<h2 id="高级主题">高级主题</h2><h3 id="范畴">范畴</h3><p>使用范畴（category），程序员可以为任何已有的类添加方法。比如可以为NSString添加一个方法VowelCount，用来计算字符串中得元音个数。（<a href="http://jingyan.baidu.com/article/3c343ff7efd4860d377963cd.html" target="_blank" rel="external">xcode6如何创建category文件？</a>）<br>如果需要在其他程序中使用vowelCount方法，需要将相应的实现文件加入项目，并在构建程序时将范畴编译进去。</p>
<h3 id="block对象">block对象</h3><p>block对象可以理解为函数指针/匿名函数/closure/lamda。</p>
<h4 id="block对象声明，定义，使用">block对象声明，定义，使用</h4><p>可以没有函数名，但为了能够通过名称使用某个block对象，需要赋给block对象变量。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明Block变量</span></span><br><span class="line"><span class="keyword">void</span> (^devowelizer)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *);</span><br><span class="line"><span class="comment">// 定义block变量</span></span><br><span class="line">devowelizer = ^(<span class="keyword">id</span> string, <span class="built_in">NSUInteger</span> i, <span class="built_in">BOOL</span> *stop) &#123; ...&#125;</span><br><span class="line"><span class="comment">// 使用block变量</span></span><br><span class="line"><span class="comment">// 枚举数组对象oldStrings，针对每个数组中的对象，执行Block对象devowelizer</span></span><br><span class="line">[oldStrings enumerateObjectsUsingBlock:devowelizer];</span><br></pre></td></tr></table></figure></p>
<h4 id="typedef">typedef</h4><p>与函数指针类似，可以用typedef来简化书写方式,定义了一个类型，而不是变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ArrayEnumerationblock)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *);</span><br><span class="line">ArrayEnumerationBlock devowelizer;</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">void</span>(^devowelizer)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span> *);</span><br></pre></td></tr></table></figure></p>
<h4 id="内存管理—todo">内存管理—todo</h4><p>基于栈的block对象,当创建block的函数或者方法完成执行并范湖ihou，相应的block对象会随着栈帧的释放而被释放。<br>基于堆的block对象</p>
<p>向block对象发送copy消息，可以将其从栈拷贝至堆。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayEnumerationBlock iVarDevowelizer = [devowelizer <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>那些由Apple提供的并且支持Block对象的方法，例如NSArray的enumerateObjectsUsing-Block:，或者NSNotificationCenter的addOb-serverForName:object:queue:usingBlock:，都会拷贝传入的Block对象，并将其保存在堆中。通过拷贝Block对象，这些方法得以创建指向保存于堆中的Block对象的指针（并且是strong特性的引用）。</p>
</blockquote>
<p>几点需要注意：—todo<br>1.对于block对象使用的变量，程序如何管理其生命期？<br>block对象中通常会使用外部创建的变量，执行block对象时，为了确保外部变量始终存在，相应的block对象会捕获这些变量。什么时候捕获呢？在将基于栈的block对象拷贝至基于堆得block对象的时候。<br>对于基本类型的变量，捕获意味着拷贝变量的值，并用block对象内的局部变量保存。对于指针类型的变量，block对象会用strong特性的引用，也就是说block对象用到的对象都会保留，所以在相应block对象释放前，这些对象一定不会被释放。</p>
<p>2.这类strong特性引用会导致retain循环问题吗？<br>有可能。当block对象所使用的对象保留了当前的block对象时。解决方法：现在block对象外声明一个__weak指针，然后将这个指针指向block对象的使用的对象，最后在block中使用这个新的对象。</p>
<p>3.可以修改block对象所拷贝的变量码？<br>被捕获的变量是常数，程序无法修改变量所保存的值。如果是指针，则不可修改指针，但是可以修改指针指向的对象。<br>如果需要在block对象内修改外部变量，可以在声明外部变量时，在前面加上<code>__block</code>.</p>
<hr>
<h2 id="其他">其他</h2><ul>
<li>xcode6如何创建空的Empty Application? 很多书特别是翻译过来的书，里面使用的环境较老，会有empty application的类型可以选择，但是新的xcode6里面就没有，需要按照下面的方法自己新建<a href="http://blog.csdn.net/ayaseeli/article/details/41725923" target="_blank" rel="external">—链接</a></li>
</ul>
<ul>
<li><code>#pragma mark --some comemnts</code>,当某个类有很多方法的时候，可以使用这个指令来帮助快速分类并定位.</li>
</ul>
<p>xcode快捷方式<br>自动补全，主题，颜色。。。</p>
<h1 id="Ref：">Ref：</h1><ul>
<li><a href="http://www.coderyi.com/archives/397" target="_blank" rel="external">ios开发路线简述</a></li>
<li><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="external">ios学习资料整理—github</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C(官网)</a></li>
<li><a href="http://cocoadevcentral.com/d/learn_objectivec/" target="_blank" rel="external">快速入门</a></li>
<li><a href="http://code.taobao.org/p/iOSProgramming/src/Chapter2/RandomItems/" target="_blank" rel="external">taobao网上得课程代码</a></li>
<li><a href="http://blog.csdn.net/wishfly/article/details/7384708" target="_blank" rel="external">Objective-C内存布局—描述isa指针是什么</a></li>
</ul>
<h1 id="todo">todo</h1><ul>
<li>ios4th</li>
<li>性能分析工具</li>
<li>iOS Simulator使用</li>
<li>实例练习</li>
<li>开源项目</li>
<li>搞起</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>oc以c语言为基础，加入了对面向对象编程（OOP）的支持。</p>
<p>工具：xcode6</p>
<p>书籍：《Objective-C编程》—Aaron Hillegass[美]</p>
<h2 id="变量与类型">变量与类型</]]>
    </summary>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/tags/iOS/"/>
    
      <category term="oc" scheme="http://shawnelee88.github.io/tags/oc/"/>
    
      <category term="iOS" scheme="http://shawnelee88.github.io/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo建站记录]]></title>
    <link href="http://shawnelee88.github.io/2015/07/09/hexo%E8%AE%B0%E5%BD%95-md/"/>
    <id>http://shawnelee88.github.io/2015/07/09/hexo记录-md/</id>
    <published>2015-07-09T14:18:06.000Z</published>
    <updated>2015-10-07T15:28:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hexo记录">hexo记录</h1><h3 id="准备工作：">准备工作：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">hexo <span class="keyword">server</span></span></span><br></pre></td></tr></table></figure>
<h3 id="主要命令：">主要命令：</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span> <span class="preprocessor">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span> <span class="preprocessor">#新建页面</span></span><br><span class="line">hexo generate <span class="preprocessor">#生成静态页面至public目录</span></span><br><span class="line">hexo <span class="keyword">server</span> <span class="preprocessor">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="preprocessor">#将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">localhost:<span class="number">4000</span> 本地查看</span><br></pre></td></tr></table></figure>
<h3 id="安装中可能出现的错误">安装中可能出现的错误</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/default/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br><span class="line"></span><br><span class="line">&#123; [<span class="string">Error:</span> Cannot find module <span class="string">'./build/Debug/DTraceProviderBindings'</span>] <span class="string">code:</span> <span class="string">'MODULE_NOT_FOUND'</span> &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/hexojs/hexo-cli/issues/1" target="_blank" rel="external">解决方法</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="hexo支持的特殊语法">hexo支持的特殊语法</h3><p>特殊的quote<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote <span class="comment">[lee<span class="comment">[, source]</span>]</span> <span class="comment">[link]</span> <span class="comment">[source_link_title]</span> %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="资源文件夹">资源文件夹</h3><p>引用本地的资源，可以先开启<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml中设置</span><br><span class="line"><span class="label">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line">几个插件：</span><br><span class="line">&#123;<span class="var_expand">% asset_path slug %</span>&#125;</span><br><span class="line">&#123;<span class="var_expand">% asset_img slug [title] %</span>&#125;</span><br><span class="line">&#123;<span class="var_expand">% asset_link slug [title] %</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考文章：</p>
<ul>
<li><a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li>atom + hexo</li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo官网</a></li>
<li><a href="http://akarin.xyz/build-your-hexo-blog/" target="_blank" rel="external">hexo静态博客使用指南</a></li>
<li><a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/" target="_blank" rel="external">Jackman主题</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[对hexo+github建站做个简单记录]]>
    
    </summary>
    
      <category term="github" scheme="http://shawnelee88.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://shawnelee88.github.io/tags/hexo/"/>
    
      <category term="杂货铺" scheme="http://shawnelee88.github.io/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
  </entry>
  
</feed>